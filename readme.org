* @amory/style
:properties:
:header-args: :cache yes :comments no :mkdirp yes :padline yes :results silent
:end:
#+startup: showall nohideblocks hidestars indent

** Table of Contents                                                   :TOC:
- [[#amorystyle][@amory/style]]
  - [[#usage][Usage]]
    - [[#with-nextjs][With Next.js]]
      - [[#pages_documentjs][pages/_document.js]]
  - [[#license][License]]
  - [[#source][Source]]
    - [[#api][API]]
      - [[#create][create]]
      - [[#css][css]]
      - [[#index][index]]
      - [[#style][style]]
    - [[#build][Build]]
      - [[#getancestors][getAncestors]]
      - [[#getblockstring][getBlockString]]
      - [[#getclassname][getClassName]]
      - [[#getplaceholders][getPlaceholders]]
      - [[#getpropertyid][getPropertyId]]
      - [[#getselectors][getSelectors]]
      - [[#getselectorsstring][getSelectorsString]]
      - [[#getstringhash][getStringHash]]
      - [[#getstyle][getStyle]]
      - [[#getstyles][getStyles]]
    - [[#client][Client]]
      - [[#canusedom][canUseDom]]
      - [[#getstyleelement][getStyleElement]]
      - [[#insertrule][insertRule]]
      - [[#update][update]]
      - [[#updatestyles][updateStyles]]
    - [[#parse][Parse]]
      - [[#parsefallbacks][parseFallbacks]]
      - [[#parsefontface][parseFontFace]]
      - [[#parseidentifier][parseIdentifier]]
      - [[#parseinput][parseInput]]
      - [[#parsekeyframes][parseKeyframes]]
      - [[#parsemedia][parseMedia]]
      - [[#parsenumbers][parseNumbers]]
      - [[#parseplaceholder][parsePlaceholder]]
      - [[#parseselectors][parseSelectors]]
      - [[#parsetypeselector][parseTypeSelector]]
      - [[#parse-1][parse]]
    - [[#store][Store]]
      - [[#cache][cache]]
      - [[#store-1][store]]
    - [[#utils][Utils]]
      - [[#camelcase][camelCase]]
      - [[#debounce][debounce]]
      - [[#kebabcase][kebabCase]]
      - [[#merge][merge]]
      - [[#pubsub][pubSub]]
      - [[#topairs][toPairs]]

** Usage

*** With Next.js

**** pages/_document.js

#+begin_src js
import { getStyles } from "@amory/style"
import Document from "next/document"
import React from "react"

export default class extends Document {
  static getInitialProps ({ renderPage }) {
    const initialProps = renderPage (
      (App) => (props) => (<App {...props} />)
    )

    return {
      ... initialProps,
      "styles": (
        <React.Fragment>
          {initialProps.styles}
          <style
            dangerouslySetInnerHTML={{ __html: getStyles () }}
            data-creator="@amory/style" />
        </React.Fragment>
      )
    }
  }
}
#+end_src

** License

#+begin_quote
Copyright 2019 [[https://github.com/ptb][Peter T Bosse II]]

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
#+end_quote

** Source

*** API

**** create

#+HTML: <details>
#+begin_src js :tangle src/api/create.js
import { css, toPairs } from "./index.js"

export function create (params = {}) {
  return toPairs (params).reduce (function (styles, style) {
    const property = style[0]
    const value = style[1]

    styles[property] = css (value)

    return styles
  }, {})
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/api/create.test.js
import ava from "ava"
import { create } from "./create.js"
import { css } from "./css.js"

ava ("given undefined arguments", (t) => {
  const actual = create ()
  const expect = {}

  t.deepEqual (actual, expect)
})

ava ("given an object with simple declarations", (t) => {
  const actual = create ({
    "banner": {
      "display": "block",
      "width": "80%"
    },
    "product": {
      "color": "#f00",
      "display": ["block", "flex", "grid"]
    }
  })

  const expect = {
    "banner": "drtx9 dtndl",
    "product": "jk2a9 dr4gk"
  }

  t.deepEqual (actual, expect)
})

/* eslint-disable max-lines-per-function */
ava ("given an object with multiple 'fontFamily' declarations", (t) => {
  const fonts = {
    "avenir300": {
      "fontFamily": {
        "fontFamily": "Avenir",
        "fontStyle": "normal",
        "fontWeight": 300,
        "src": "url(/fonts/avenir-300-light-normal.woff) format(woff)"
      }
    },
    "avenir300i": {
      "fontFamily": {
        "fontFamily": "Avenir",
        "fontStyle": "italic",
        "fontWeight": 300,
        "src": "url(/fonts/avenir-300-light-oblique.woff) format(woff)"
      }
    },
    "avenir400": {
      "fontFamily": {
        "fontFamily": "Avenir",
        "fontStyle": "normal",
        "fontWeight": 400,
        "src": "url(/fonts/avenir-400-book-normal.woff) format(woff)"
      }
    },
    "avenir400i": {
      "fontFamily": {
        "fontFamily": "Avenir",
        "fontStyle": "italic",
        "fontWeight": 400,
        "src": "url(/fonts/avenir-400-book-oblique.woff) format(woff)"
      }
    },
    "avenir500": {
      "fontFamily": {
        "fontFamily": "Avenir",
        "fontStyle": "normal",
        "fontWeight": 500,
        "src": "url(/fonts/avenir-500-roman-normal.woff) format(woff)"
      }
    },
    "avenir500i": {
      "fontFamily": {
        "fontFamily": "Avenir",
        "fontStyle": "italic",
        "fontWeight": 500,
        "src": "url(/fonts/avenir-500-roman-oblique.woff) format(woff)"
      }
    },
    "avenir600": {
      "fontFamily": {
        "fontFamily": "Avenir",
        "fontStyle": "normal",
        "fontWeight": 600,
        "src": "url(/fonts/avenir-600-medium-normal.woff) format(woff)"
      }
    },
    "avenir600i": {
      "fontFamily": {
        "fontFamily": "Avenir",
        "fontStyle": "italic",
        "fontWeight": 600,
        "src": "url(/fonts/avenir-600-medium-oblique.woff) format(woff)"
      }
    },
    "avenir700": {
      "fontFamily": {
        "fontFamily": "Avenir",
        "fontStyle": "normal",
        "fontWeight": 700,
        "src": "url(/fonts/avenir-700-heavy-normal.woff) format(woff)"
      }
    },
    "avenir700i": {
      "fontFamily": {
        "fontFamily": "Avenir",
        "fontStyle": "italic",
        "fontWeight": 700,
        "src": "url(/fonts/avenir-700-heavy-oblique.woff) format(woff)"
      }
    },
    "avenir800": {
      "fontFamily": {
        "fontFamily": "Avenir",
        "fontStyle": "normal",
        "fontWeight": 800,
        "src": "url(/fonts/avenir-800-black-normal.woff) format(woff)"
      }
    },
    "avenir800i": {
      "fontFamily": {
        "fontFamily": "Avenir",
        "fontStyle": "italic",
        "fontWeight": 800,
        "src": "url(/fonts/avenir-800-black-oblique.woff) format(woff)"
      }
    }
  }

  const actual1 = create (fonts)

  const expect1 = {
    "avenir300": "c5w4b",
    "avenir300i": "c59u0",
    "avenir400": "c5krw",
    "avenir400i": "c5c5b",
    "avenir500": "c5ji2",
    "avenir500i": "c5qt3",
    "avenir600": "c5ync",
    "avenir600i": "c5vw5",
    "avenir700": "c5j0a",
    "avenir700i": "c5xmd",
    "avenir800": "c5h5q",
    "avenir800i": "c5sr5"
  }

  const actual2 = css (fonts.avenir300)

  const expect2 = "c5w4b"

  t.deepEqual (actual1, expect1)
  t.deepEqual (actual2, expect2)
})
/* eslint-enable max-lines-per-function */
#+end_src
#+HTML: </details>

**** css

#+HTML: <details>
#+begin_src js :tangle src/api/css.js
import { cache, getClassName, isArr, merge, parse, update } from "./index.js"

export function css (params) {
  const input = isArr (params) ? merge (... params) : params

  return parse ({ input })
    .map (cache)
    .map (update)
    .map (getClassName)
    .filter (Boolean)
    .join (" ")
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/api/css.test.js
import ava from "ava"
import { store } from "../store/store.js"
import { css } from "./css.js"

function strMapToObj (strMap) {
  const obj = Object.create (null)

  for (const [k, v] of strMap) {
    obj[k] = v
  }

  return obj
}

ava ("given undefined arguments", (t) => {
  const actual = css ()
  const expect = ""

  t.deepEqual (actual, expect)
})

ava ("given an object with simple declarations", (t) => {
  const actual1 = css ({
    "backgroundColor": "#f00",
    "display": "block"
  })

  const expect1 = "jt2a9 drtx9"

  const actual2 = strMapToObj (store.get (""))

  const expect2 = {
    '[{"background-color":"#f00"}]': {
      "block": [
        {
          "background-color": "#f00"
        }
      ],
      "emit": true,
      "identifier": "jt2a9",
      "input": {
        "backgroundColor": "#f00"
      },
      "media": "",
      "property": "backgroundColor",
      "selectors": [[".jt2a9"]],
      "value": "#f00"
    },
    '[{"display":"block"}]': {
      "block": [
        {
          "display": "block"
        }
      ],
      "emit": true,
      "identifier": "drtx9",
      "input": {
        "display": "block"
      },
      "media": "",
      "property": "display",
      "selectors": [[".drtx9"]],
      "value": "block"
    }
  }

  t.is (actual1, expect1)
  t.deepEqual (actual2, expect2)
})

ava ("given an array of objects with simple declarations", (t) => {
  const actual = css ([
    {
      "backgroundColor": "#f00",
      "display": "block"
    },
    {
      "backgroundColor": "#0f0"
    }
  ])

  const expect = "jtz4h drtx9"

  t.is (actual, expect)
})
#+end_src
#+HTML: </details>

**** index

#+HTML: <details>
#+begin_src js :tangle src/api/index.js
export { create } from "./create.js"
export { css } from "./css.js"
export { getAncestors } from "../build/get-ancestors.js"
export { getBlockString } from "../build/get-block-string.js"
export { getClassName } from "../build/get-class-name.js"
export { getPlaceholders } from "../build/get-placeholders.js"
export { getPropertyId } from "../build/get-property-id.js"
export { getSelectors } from "../build/get-selectors.js"
export { getSelectorsString } from "../build/get-selectors-string.js"
export { getStringHash } from "../build/get-string-hash.js"
export { getStyle } from "../build/get-style.js"
export { getStyles } from "../build/get-styles.js"
export { canUseDom } from "../client/can-use-dom.js"
export { getStyleElement } from "../client/get-style-element.js"
export { insertRule } from "../client/insert-rule.js"
export { update } from "../client/update.js"
export { updateStyles } from "../client/update-styles.js"
export { parse } from "../parse/parse.js"
export { parseFallbacks } from "../parse/parse-fallbacks.js"
export { parseFontFace } from "../parse/parse-font-face.js"
export { parseIdentifier } from "../parse/parse-identifier.js"
export { parseInput } from "../parse/parse-input.js"
export { parseKeyframes } from "../parse/parse-keyframes.js"
export { parseMedia } from "../parse/parse-media.js"
export { parseNumbers } from "../parse/parse-numbers.js"
export { parsePlaceholder } from "../parse/parse-placeholder.js"
export { parseSelectors } from "../parse/parse-selectors.js"
export { parseTypeSelector } from "../parse/parse-type-selector.js"
export { cache } from "../store/cache.js"
export { store } from "../store/store.js"
export { camelCase } from "../utils/camel-case.js"
export { debounce } from "../utils/debounce.js"
export { kebabCase } from "../utils/kebab-case.js"
export {
  canMerge,
  cloneObj,
  emptyObj,
  isArr,
  isDef,
  isNum,
  isObj,
  merge,
  mergeArr,
  mergeObj
} from "../utils/merge.js"
export { pubSub } from "../utils/pub-sub.js"
export { toPairs } from "../utils/to-pairs.js"
#+end_src
#+HTML: </details>

**** style

#+HTML: <details>
#+begin_src js :tangle src/api/style.js
export { create } from "./create.js"
export { css } from "./css.js"
export { getStyles } from "../build/get-styles.js"
export { merge } from "../utils/merge.js"
#+end_src
#+HTML: </details>

*** Build

**** getAncestors

#+HTML: <details>
#+begin_src js :tangle src/build/get-ancestors.js
export function getAncestors (ancestors = [], selectors = []) {
  return selectors.reduce (function (results, selector) {
    if (ancestors.length) {
      const index = selector.indexOf ("&")

      ancestors.forEach (function (ancestor) {
        results.push (
          index < 0
            ? ancestor.concat (" ", selector)
            : selector
              .slice (0, index)
              .concat (ancestor, selector.slice (index + 1))
        )
      })

      return results
    }

    return results.concat ([selector])
  }, [])
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/build/get-ancestors.test.js
import ava from "ava"
import { getAncestors } from "./get-ancestors.js"

ava ("given undefined arguments", (t) => {
  const actual = getAncestors ()

  const expect = []

  t.deepEqual (actual, expect)
})

ava ("given an array of selectors without ancestors", (t) => {
  const actual = getAncestors ([], [["#root"]])

  const expect = [["#root"]]

  t.deepEqual (actual, expect)
})

ava ("given an array of selectors with implied ancestor location", (t) => {
  const actual = getAncestors ([["#root"]], [["#body"]])

  const expect = [["#root", " ", "#body"]]

  t.deepEqual (actual, expect)
})

ava ("given an array of selectors with defined ancestor prefix", (t) => {
  const actual = getAncestors ([["#root"]], [["&", " ", "#body"]])

  const expect = [["#root", " ", "#body"]]

  t.deepEqual (actual, expect)
})

ava ("given an array of selectors with defined ancestor suffix", (t) => {
  const actual = getAncestors ([["#root"]], [["#body", " ", "&"]])

  const expect = [["#body", " ", "#root"]]

  t.deepEqual (actual, expect)
})

ava ("given an array of selectors with defined ancestor middle", (t) => {
  const actual = getAncestors (
    [["#root"]],
    [["#body", " ", "&", " ", "%thing"]]
  )

  const expect = [["#body", " ", "#root", " ", "%thing"]]

  t.deepEqual (actual, expect)
})

ava ("given an array of selectors with array of ancestors", (t) => {
  const actual = getAncestors (
    [["#root", "#body"], ["%test"]],
    [["#more", ">", "%stuff"], ["#thing", " ", "&", "+", "%thing"]]
  )

  const expect = [
    ["#root", "#body", " ", "#more", ">", "%stuff"],
    ["%test", " ", "#more", ">", "%stuff"],
    ["#thing", " ", "#root", "#body", "+", "%thing"],
    ["#thing", " ", "%test", "+", "%thing"]
  ]

  t.deepEqual (actual, expect)
})
#+end_src
#+HTML: </details>

**** getBlockString

#+HTML: <details>
#+begin_src js :tangle src/build/get-block-string.js
import { isObj, kebabCase, toPairs } from "../api/index.js"

export function getBlockString (params = {}) {
  const block = params.block || []

  let sep = ";"

  return block
    .map (function (rule) {
      return toPairs (rule).map (function (style) {
        const property = style[0]
        const value = style[1]

        if (isObj (value)) {
          const a = toPairs (value)
            .map (function (b) {
              return kebabCase (b[0]).concat (":", b[1])
            })
            .join (";")

          sep = ""

          return "".concat (property, "{", a, "}")
        }

        return "".concat (property, ":", value)
      })
    })
    .join (sep)
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/build/get-block-string.test.js
import ava from "ava"
import { getBlockString } from "./get-block-string.js"

ava ("given undefined arguments", (t) => {
  const actual = getBlockString ()

  const expect = ""

  t.is (actual, expect)
})

ava ("given a block with simple property and value", (t) => {
  const actual = getBlockString ({
    "block": [
      {
        "background-color": "#f00"
      }
    ]
  })

  const expect = "background-color:#f00"

  t.is (actual, expect)
})

ava ("given a block with fallback properties and value", (t) => {
  const actual = getBlockString ({
    "block": [
      {
        "background-color": "#f00"
      },
      {
        "background-color": "rgba(255, 0, 0, 0.9)"
      }
    ]
  })

  const expect = "background-color:#f00;background-color:rgba(255, 0, 0, 0.9)"

  t.is (actual, expect)
})

ava ("given a block with keyframes object", (t) => {
  const actual = getBlockString ({
    "block": [
      { "0%": { "backgroundColor": "#f00", "opacity": 0 } },
      { "100%": { "backgroundColor": "#0f0", "opacity": 1 } }
    ]
  })

  const expect =
    "0%{background-color:#f00;opacity:0}100%{background-color:#0f0;opacity:1}"

  t.is (actual, expect)
})
#+end_src
#+HTML: </details>

**** getClassName

#+HTML: <details>
#+begin_src js :tangle src/build/get-class-name.js
export function getClassName (params = {}) {
  const emit = params.emit
  const identifier = params.identifier

  return emit ? identifier : null
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/build/get-class-name.test.js
import ava from "ava"
import { getClassName } from "./get-class-name.js"

ava ("given undefined arguments", (t) => {
  const actual = getClassName ()

  const expect = null

  t.deepEqual (actual, expect)
})

ava ("given an object with identifier and emit true", (t) => {
  const actual = getClassName ({
    "emit": true,
    "identifier": "jtz4h",
    "property": "backgroundColor",
    "selectors": [[".jtz4h"]],
    "value": "#0f0"
  })

  const expect = "jtz4h"

  t.deepEqual (actual, expect)
})

ava ("given an object with identifier and emit false", (t) => {
  const actual = getClassName ({
    "block": [
      {
        "src":
          "url('/fonts/font.woff2') format ('woff2'), url('/fonts/font.woff') format ('woff')"
      },
      {
        "font-family": "c5xq1"
      }
    ],
    "emit": false,
    "identifier": "c5xq1",
    "input": {
      "fontFamily": {
        "src":
          "url('/fonts/font.woff2') format ('woff2'), url('/fonts/font.woff') format ('woff')"
      }
    },
    "media": "",
    "property": "fontFamily",
    "selectors": [["@font-face"]],
    "value": {
      "src":
        "url('/fonts/font.woff2') format ('woff2'), url('/fonts/font.woff') format ('woff')"
    }
  })

  const expect = null

  t.deepEqual (actual, expect)
})
#+end_src
#+HTML: </details>

**** getPlaceholders

#+HTML: <details>
#+begin_src js :tangle src/build/get-placeholders.js
import { parseIdentifier } from "../api/index.js"

export function getPlaceholders (selectors = []) {
  return selectors.map (function (selector) {
    return (/^%/u).test (selector)
      ? ".".concat (
        parseIdentifier ({
          "property": selector,
          "value": selector
        }).identifier
      )
      : selector
  })
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/build/get-placeholders.test.js
import ava from "ava"
import { getPlaceholders } from "./get-placeholders.js"

ava ("given undefined arguments", (t) => {
  const actual = getPlaceholders ()

  const expect = []

  t.deepEqual (actual, expect)
})

ava ("given an array of selectors with placeholders", (t) => {
  const actual = getPlaceholders (["a", "%b", ".c", "%products", "%items"])

  const expect = ["a", ".afqkz", ".c", ".afknd", ".afxpz"]

  t.deepEqual (actual, expect)
})
#+end_src
#+HTML: </details>

**** getPropertyId

#+HTML: <details>
#+begin_src js :tangle src/build/get-property-id.js
import { camelCase } from "../api/index.js"

/**
 * @param {string} propertyName
 * - Property name/identifier specifying a stylistic CSS feature to change.
 *
 * @returns {number}
 */

export function getPropertyId (propertyName = "") {
  const n = parseInt ("af", 36)

  switch (true) {
    case (/^%/u).test (propertyName):
      return 0 + n
    case (/^\x2D\x2D/u).test (propertyName):
      return 1 + n
    default:
      return (
        "$*,--*,all,direction,unicodeBidi,writingMode,textOrientation,glyphOrientationVertical,textCombineUpright,textTransform,whiteSpace,textSpaceCollapse,textSpaceTrim,tabSize,wordBreak,lineBreak,hyphens,overflowWrap,wordWrap,textWrap,wrapBefore,wrapAfter,wrapInside,hyphenateCharacter,hyphenateLimitZone,hyphenateLimitChars,hyphenateLimitLines,hyphenateLimitLast,textAlign,textAlignAll,textAlignLast,textJustify,textGroupAlign,wordSpacing,letterSpacing,linePadding,textSpacing,textIndent,hangingPunctuation,textDecoration,textDecorationLine,textDecorationStyle,textDecorationColor,textDecorationWidth,textDecorationSkip,textDecorationSkipInk,textUnderlineOffset,textUnderlinePosition,textEmphasis,textEmphasisStyle,textEmphasisColor,textEmphasisPosition,textEmphasisSkip,textShadow,src,font,fontStyle,fontVariant,fontWeight,fontStretch,fontSize,lineHeight,fontFamily,fontMinSize,fontMaxSize,fontSizeAdjust,fontSynthesis,fontSynthesisWeight,fontSynthesisStyle,fontSynthesisSmallCaps,unicodeRange,fontFeatureSettings,fontVariationSettings,fontLanguageOverride,fontKerning,fontVariantLigatures,fontVariantPosition,fontVariantCaps,fontVariantNumeric,fontVariantAlternates,fontVariantEastAsian,fontOpticalSizing,fontPalette,fontVariantEmoji,content,quotes,stringSet,bookmarkLevel,bookmarkLabel,bookmarkState,running,footnoteDisplay,footnotePolicy,outline,outlineColor,outlineStyle,outlineWidth,outlineOffset,resize,textOverflow,cursor,caret,caretColor,caretShape,navUp,navRight,navDown,navLeft,userSelect,appearance,position,top,right,bottom,left,offsetBefore,offsetAfter,offsetStart,offsetEnd,zIndex,display,contain,width,height,minWidth,minHeight,maxWidth,maxHeight,boxSizing,visibility,pageBreakBefore,pageBreakAfter,pageBreakInside,margin,marginTop,marginRight,marginBottom,marginLeft,marginTrim,padding,paddingTop,paddingRight,paddingBottom,paddingLeft,dominantBaseline,verticalAlign,alignmentBaseline,baselineShift,inlineSizing,initialLetters,initialLettersAlign,initialLettersWrap,listStyle,listStyleType,listStylePosition,listStyleImage,markerSide,counterReset,counterSet,counterIncrement,overflow,overflowX,overflowY,overflowBlock,overflowInline,blockOverflow,lineClamp,maxLines,continue,tableLayout,borderCollapse,borderSpacing,captionSide,emptyCells,flexFlow,flexDirection,flexWrap,order,flex,flexGrow,flexShrink,flexBasis,placeContent,alignContent,justifyContent,placeItems,alignItems,justifyItems,placeSelf,alignSelf,justifySelf,gap,rowGap,columnGap,columns,columnWidth,columnCount,columnRule,columnRuleWidth,columnRuleStyle,columnRuleColor,columnSpan,columnFill,flowInto,flowFrom,regionFragment,breakBefore,breakAfter,breakInside,orphans,widows,boxDecorationBreak,grid,gridTemplate,gridTemplateRows,gridTemplateColumns,gridTemplateAreas,gridAutoFlow,gridAutoRows,gridAutoColumns,gridArea,gridRow,gridRowStart,gridRowEnd,gridColumn,gridColumnStart,gridColumnEnd,rubyPosition,rubyMerge,rubyAlign,float,clear,blockSize,inlineSize,minBlockSize,minInlineSize,maxBlockSize,maxInlineSize,marginBlock,marginBlockStart,marginBlockEnd,marginInline,marginInlineStart,marginInlineEnd,inset,insetBlock,insetBlockStart,insetBlockEnd,insetInline,insetInlineStart,insetInlineEnd,paddingBlock,paddingBlockStart,paddingBlockEnd,paddingInline,paddingInlineStart,paddingInlineEnd,borderBlockWidth,borderBlockStartWidth,borderBlockEndWidth,borderInlineWidth,borderInlineStartWidth,borderInlineEndWidth,borderBlockStyle,borderBlockStartStyle,borderBlockEndStyle,borderInlineStyle,borderInlineStartStyle,borderInlineEndStyle,borderBlockColor,borderBlockStartColor,borderBlockEndColor,borderInlineColor,borderInlineStartColor,borderInlineEndColor,borderBlock,borderBlockStart,borderBlockEnd,borderInline,borderInlineStart,borderInlineEnd,borderStartStartRadius,borderStartEndRadius,borderEndStartRadius,borderEndEndRadius,fillRule,fillBreak,fill,fillColor,fillImage,fillOrigin,fillPosition,fillSize,fillRepeat,fillOpacity,strokeWidth,strokeAlign,strokeLinecap,strokeLinejoin,strokeMiterlimit,strokeBreak,strokeDasharray,strokeDashoffset,strokeDashCorner,strokeDashJustify,stroke,strokeColor,strokeImage,strokeOrigin,strokePosition,strokeSize,strokeRepeat,strokeOpacity,marker,markerStart,markerMid,markerEnd,markerSegment,markerPattern,markerKnockoutLeft,markerKnockoutRight,vectorEffect,colorRendering,shapeRendering,textRendering,imageRendering,bufferedRendering,stopColor,stopOpacity,color,opacity,colorAdjust,objectFit,objectPosition,imageResolution,imageOrientation,imageRendering,background,backgroundColor,backgroundImage,backgroundPosition,backgroundPositionX,backgroundPositionY,backgroundSize,backgroundRepeat,backgroundAttachment,backgroundOrigin,backgroundClip,border,borderTop,borderRight,borderBottom,borderLeft,borderWidth,borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth,borderStyle,borderTopStyle,borderRightStyle,borderBottomStyle,borderLeftStyle,borderColor,borderTopColor,borderRightColor,borderBottomColor,borderLeftColor,borderRadius,borderTopLeftRadius,borderTopRightRadius,borderBottomRightRadius,borderBottomLeftRadius,borderImage,borderImageSource,borderImageSlice,borderImageWidth,borderImageOutset,borderImageRepeat,boxShadow,clip,clipPath,clipRule,mask,maskImage,maskPosition,maskSize,maskRepeat,maskOrigin,maskClip,maskComposite,maskMode,maskBorder,maskBorderSource,maskBorderSlice,maskBorderWidth,maskBorderOutset,maskBorderRepeat,maskBorderMode,maskType,shapeOutside,shapeImageThreshold,shapeMargin,filter,floodColor,floodOpacity,colorInterpolationFilters,lightingColor,mixBlendMode,isolation,backgroundBlendMode,transition,transitionProperty,transitionDuration,transitionTimingFunction,transitionDelay,transform,transformOrigin,transformBox,transformStyle,perspective,perspectiveOrigin,backfaceVisibility,animation,animationName,animationDuration,animationTimingFunction,animationDelay,animationIterationCount,animationDirection,animationFillMode,animationPlayState,offset,offsetPosition,offsetPath,offsetDistance,offsetRotate,offsetAnchor,willChange,scrollSnapType,scrollPadding,scrollPaddingTop,scrollPaddingRight,scrollPaddingBottom,scrollPaddingLeft,scrollPaddingBlock,scrollPaddingBlockStart,scrollPaddingBlockEnd,scrollPaddingInline,scrollPaddingInlineStart,scrollPaddingInlineEnd,scrollMargin,scrollMarginTop,scrollMarginRight,scrollMarginBottom,scrollMarginLeft,scrollMarginBlock,scrollMarginBlockStart,scrollMarginBlockEnd,scrollMarginInline,scrollMarginInlineStart,scrollMarginInlineEnd,scrollSnapAlign,scrollSnapStop,scrollBehavior"
          .split (",")
          .indexOf (
            camelCase (propertyName)
              .replace (/^(Moz|Ms|Webkit)/u, "")
              .replace (/^([A-Z])/u, function (a) {
                return a.toLowerCase ()
              })
          ) + n
      )
  }
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src json :tangle src/build/get-property-id.json
{
  "variables": [
    "%*",
    "--*"
  ],

  "cascade": [
    "all"
  ],

  "writingModes": [
    "direction",
    "unicodeBidi",
    "writingMode",
    "textOrientation",
    "glyphOrientationVertical",
    "textCombineUpright"
  ],

  "text": [
    "textTransform",

    "whiteSpace",
    "textSpaceCollapse",
    "textSpaceTrim",
    "tabSize",

    "wordBreak",
    "lineBreak",
    "hyphens",
    "overflowWrap",
    "wordWrap",

    "textWrap",
    "wrapBefore",
    "wrapAfter",
    "wrapInside",

    "hyphenateCharacter",
    "hyphenateLimitZone",
    "hyphenateLimitChars",
    "hyphenateLimitLines",
    "hyphenateLimitLast",

    "textAlign",
    "textAlignAll",
    "textAlignLast",
    "textJustify",
    "textGroupAlign",

    "wordSpacing",
    "letterSpacing",
    "linePadding",
    "textSpacing",

    "textIndent",
    "hangingPunctuation"
  ],

  "textDecor": [
    "textDecoration",
    "textDecorationLine",
    "textDecorationStyle",
    "textDecorationColor",

    "textDecorationWidth",
    "textDecorationSkip",
    "textDecorationSkipInk",

    "textUnderlineOffset",
    "textUnderlinePosition",

    "textEmphasis",
    "textEmphasisStyle",
    "textEmphasisColor",

    "textEmphasisPosition",

    "textEmphasisSkip",

    "textShadow"
  ],

  "fonts": [
    "src",

    "font",
    "fontStyle",
    "fontVariant",
    "fontWeight",
    "fontStretch",
    "fontSize",
    "lineHeight",
    "fontFamily",

    "fontMinSize",
    "fontMaxSize",
    "fontSizeAdjust",

    "fontSynthesis",
    "fontSynthesisWeight",
    "fontSynthesisStyle",
    "fontSynthesisSmallCaps",

    "unicodeRange",

    "fontFeatureSettings",
    "fontVariationSettings",
    "fontLanguageOverride",

    "fontKerning",

    "fontVariantLigatures",
    "fontVariantPosition",
    "fontVariantCaps",
    "fontVariantNumeric",
    "fontVariantAlternates",
    "fontVariantEastAsian",

    "fontOpticalSizing",

    "fontPalette",
    "fontVariantEmoji"
  ],

  "content": [
    "content",
    "quotes",
    "stringSet",
    "bookmarkLevel",
    "bookmarkLabel",
    "bookmarkState"
  ],

  "gcpm": [
    "running",
    "footnoteDisplay",
    "footnotePolicy"
  ],

  "ui": [
    "outline",
    "outlineColor",
    "outlineStyle",
    "outlineWidth",

    "outlineOffset",
    "resize",
    "textOverflow",
    "cursor",

    "caret",
    "caretColor",
    "caretShape",

    "navUp",
    "navRight",
    "navDown",
    "navLeft",

    "userSelect",
    "appearance"
  ],

  "position": [
    "position",

    "top",
    "right",
    "bottom",
    "left",

    "offsetBefore",
    "offsetAfter",
    "offsetStart",
    "offsetEnd",

    "zIndex"
  ],

  "display": [
    "display"
  ],

  "contain": [
    "contain"
  ],

  "sizing": [
    "width",
    "height",

    "minWidth",
    "minHeight",

    "maxWidth",
    "maxHeight",

    "boxSizing"
  ],

  "css2": [
    "visibility",

    "pageBreakBefore",
    "pageBreakAfter",
    "pageBreakInside"
  ],

  "box": [
    "margin",
    "marginTop",
    "marginRight",
    "marginBottom",
    "marginLeft",

    "marginTrim",

    "padding",
    "paddingTop",
    "paddingRight",
    "paddingBottom",
    "paddingLeft"
  ],

  "inline": [
    "dominantBaseline",
    "verticalAlign",
    "alignmentBaseline",
    "baselineShift",

    "inlineSizing",

    "initialLetters",
    "initialLettersAlign",
    "initialLettersWrap"
  ],

  "lists": [
    "listStyle",
    "listStyleType",
    "listStylePosition",
    "listStyleImage",

    "markerSide",

    "counterReset",
    "counterSet",
    "counterIncrement"
  ],

  "overflow": [
    "overflow",
    "overflowX",
    "overflowY",

    "overflowBlock",
    "overflowInline",

    "blockOverflow",
    "lineClamp",
    "maxLines",
    "continue"
  ],

  "tables": [
    "tableLayout",
    "borderCollapse",
    "borderSpacing",
    "captionSide",

    "emptyCells"
  ],

  "flexbox": [
    "flexFlow",
    "flexDirection",
    "flexWrap",

    "order",

    "flex",
    "flexGrow",
    "flexShrink",
    "flexBasis"
  ],

  "align": [
    "placeContent",
    "alignContent",
    "justifyContent",

    "placeItems",
    "alignItems",
    "justifyItems",

    "placeSelf",
    "alignSelf",
    "justifySelf",

    "gap",
    "rowGap",
    "columnGap"
  ],

  "multicol": [
    "columns",
    "columnWidth",
    "columnCount",

    "columnRule",
    "columnRuleWidth",
    "columnRuleStyle",
    "columnRuleColor",

    "columnSpan",
    "columnFill"
  ],

  "regions": [
    "flowInto",
    "flowFrom",
    "regionFragment"
  ],

  "break": [
    "breakBefore",
    "breakAfter",
    "breakInside",
    "orphans",
    "widows",
    "boxDecorationBreak"
  ],

  "grid": [
    "grid",

    "gridTemplate",
    "gridTemplateRows",
    "gridTemplateColumns",
    "gridTemplateAreas",

    "gridAutoFlow",
    "gridAutoRows",
    "gridAutoColumns",

    "gridArea",

    "gridRow",
    "gridRowStart",
    "gridRowEnd",

    "gridColumn",
    "gridColumnStart",
    "gridColumnEnd"
  ],

  "ruby": [
    "rubyPosition",
    "rubyMerge",
    "rubyAlign"
  ],

  "logical": [
    "float",
    "clear",

    "blockSize",
    "inlineSize",
    "minBlockSize",
    "minInlineSize",
    "maxBlockSize",
    "maxInlineSize",

    "marginBlock",
    "marginBlockStart",
    "marginBlockEnd",

    "marginInline",
    "marginInlineStart",
    "marginInlineEnd",

    "inset",
    "insetBlock",
    "insetBlockStart",
    "insetBlockEnd",
    "insetInline",
    "insetInlineStart",
    "insetInlineEnd",

    "paddingBlock",
    "paddingBlockStart",
    "paddingBlockEnd",
    "paddingInline",
    "paddingInlineStart",
    "paddingInlineEnd",

    "borderBlockWidth",
    "borderBlockStartWidth",
    "borderBlockEndWidth",
    "borderInlineWidth",
    "borderInlineStartWidth",
    "borderInlineEndWidth",

    "borderBlockStyle",
    "borderBlockStartStyle",
    "borderBlockEndStyle",
    "borderInlineStyle",
    "borderInlineStartStyle",
    "borderInlineEndStyle",

    "borderBlockColor",
    "borderBlockStartColor",
    "borderBlockEndColor",
    "borderInlineColor",
    "borderInlineStartColor",
    "borderInlineEndColor",

    "borderBlock",
    "borderBlockStart",
    "borderBlockEnd",
    "borderInline",
    "borderInlineStart",
    "borderInlineEnd",

    "borderStartStartRadius",
    "borderStartEndRadius",
    "borderEndStartRadius",
    "borderEndEndRadius"
  ],

  "fillStroke": [
    "fillRule",
    "fillBreak",

    "fill",
    "fillColor",
    "fillImage",
    "fillOrigin",
    "fillPosition",
    "fillSize",
    "fillRepeat",

    "fillOpacity",

    "strokeWidth",
    "strokeAlign",
    "strokeLinecap",
    "strokeLinejoin",
    "strokeMiterlimit",
    "strokeBreak",
    "strokeDasharray",
    "strokeDashoffset",
    "strokeDashCorner",
    "strokeDashJustify",

    "stroke",
    "strokeColor",
    "strokeImage",
    "strokeOrigin",
    "strokePosition",
    "strokeSize",
    "strokeRepeat",

    "strokeOpacity"
  ],

  "svgMarkers": [
    "marker",
    "markerStart",
    "markerMid",
    "markerEnd",

    "markerSegment",
    "markerPattern",

    "markerKnockoutLeft",
    "markerKnockoutRight"
  ],

  "svgTiny": [
    "vectorEffect",

    "colorRendering",
    "shapeRendering",
    "textRendering",
    "imageRendering",
    "bufferedRendering",

    "stopColor",
    "stopOpacity"
  ],

  "color": [
    "color",
    "opacity",

    "colorAdjust"
  ],

  "images": [
    "objectFit",
    "objectPosition",

    "imageResolution",
    "imageOrientation",
    "imageRendering"
  ],

  "backgrounds": [
    "background",
    "backgroundColor",
    "backgroundImage",
    "backgroundPosition",
    "backgroundPositionX",
    "backgroundPositionY",
    "backgroundSize",
    "backgroundRepeat",
    "backgroundAttachment",
    "backgroundOrigin",
    "backgroundClip",

    "border",
    "borderTop",
    "borderRight",
    "borderBottom",
    "borderLeft",

    "borderWidth",
    "borderTopWidth",
    "borderRightWidth",
    "borderBottomWidth",
    "borderLeftWidth",

    "borderStyle",
    "borderTopStyle",
    "borderRightStyle",
    "borderBottomStyle",
    "borderLeftStyle",

    "borderColor",
    "borderTopColor",
    "borderRightColor",
    "borderBottomColor",
    "borderLeftColor",

    "borderRadius",
    "borderTopLeftRadius",
    "borderTopRightRadius",
    "borderBottomRightRadius",
    "borderBottomLeftRadius",

    "borderImage",
    "borderImageSource",
    "borderImageSlice",
    "borderImageWidth",
    "borderImageOutset",
    "borderImageRepeat",

    "boxShadow"
  ],

  "masking": [
    "clip",
    "clipPath",
    "clipRule",

    "mask",
    "maskImage",
    "maskPosition",
    "maskSize",
    "maskRepeat",
    "maskOrigin",
    "maskClip",
    "maskComposite",
    "maskMode",

    "maskBorder",
    "maskBorderSource",
    "maskBorderSlice",
    "maskBorderWidth",
    "maskBorderOutset",
    "maskBorderRepeat",
    "maskBorderMode",

    "maskType"
  ],

  "shapes": [
    "shapeOutside",
    "shapeImageThreshold",
    "shapeMargin"
  ],

  "filterEffects": [
    "filter",
    "floodColor",
    "floodOpacity",
    "colorInterpolationFilters",
    "lightingColor"
  ],

  "compositing": [
    "mixBlendMode",
    "isolation",
    "backgroundBlendMode"
  ],

  "transitions": [
    "transition",
    "transitionProperty",
    "transitionDuration",
    "transitionTimingFunction",
    "transitionDelay"
  ],

  "transforms": [
    "transform",
    "transformOrigin",
    "transformBox",
    "transformStyle",

    "perspective",
    "perspectiveOrigin",
    "backfaceVisibility"
  ],

  "animations": [
    "animation",
    "animationName",
    "animationDuration",
    "animationTimingFunction",
    "animationDelay",
    "animationIterationCount",
    "animationDirection",
    "animationFillMode",
    "animationPlayState"
  ],

  "motion": [
    "offset",
    "offsetPosition",
    "offsetPath",
    "offsetDistance",
    "offsetRotate",
    "offsetAnchor"
  ],

  "willChange": [
    "willChange"
  ],

  "scrollSnap": [
    "scrollSnapType",

    "scrollPadding",
    "scrollPaddingTop",
    "scrollPaddingRight",
    "scrollPaddingBottom",
    "scrollPaddingLeft",

    "scrollPaddingBlock",
    "scrollPaddingBlockStart",
    "scrollPaddingBlockEnd",

    "scrollPaddingInline",
    "scrollPaddingInlineStart",
    "scrollPaddingInlineEnd",

    "scrollMargin",
    "scrollMarginTop",
    "scrollMarginRight",
    "scrollMarginBottom",
    "scrollMarginLeft",

    "scrollMarginBlock",
    "scrollMarginBlockStart",
    "scrollMarginBlockEnd",

    "scrollMarginInline",
    "scrollMarginInlineStart",
    "scrollMarginInlineEnd",

    "scrollSnapAlign",
    "scrollSnapStop"
  ],

  "cssomView": [
    "scrollBehavior"
  ]
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/build/get-property-id.test.js
import ava from "ava"
import { getPropertyId } from "./get-property-id.js"

ava ("given undefined arguments", (t) => {
  const actual = getPropertyId ()
  const expect = 374

  t.is (actual, expect)
})

ava ("given an empty string", (t) => {
  const actual = getPropertyId ("")
  const expect = 374

  t.is (actual, expect)
})

ava ("given a string with an invalid property name", (t) => {
  const actual = getPropertyId ("xyz")
  const expect = 374

  t.is (actual, expect)
})

ava ("given a string with a valid placeholder class name", (t) => {
  const actual = getPropertyId ("%productList")
  const expect = 375

  t.is (actual, expect)
})

ava ("given a string with a valid CSS variable name", (t) => {
  const actual = getPropertyId ("--background-color")
  const expect = 376

  t.is (actual, expect)
})

ava ("given a string with a valid property name (1)", (t) => {
  const actual = getPropertyId ("background")
  const expect = 712

  t.is (actual, expect)
})

ava ("given a string with a valid property name (2)", (t) => {
  const actual = getPropertyId ("background-color")
  const expect = 713

  t.is (actual, expect)
})

ava ("given a string with a prefixed property name (1)", (t) => {
  const actual = getPropertyId ("-webkit-appearance")
  const expect = 484

  t.is (actual, expect)
})

ava ("given a string with a prefixed property name (2)", (t) => {
  const actual = getPropertyId ("MozUserSelect")
  const expect = 483

  t.is (actual, expect)
})
#+end_src
#+HTML: </details>

**** getSelectors

#+HTML: <details>
#+begin_src js :tangle src/build/get-selectors.js
/**
 * @param {string} selectors
 * - String identifying the elements to which a set of CSS rulesets apply.
 *
 * @returns {?RegExpMatchArray}
 */

export function getSelectors (selectors = "") {
  const identifier =
    "-?[A-Z_a-z\\u{00a0}-\\u{ffff}]+[-0-9A-Z_a-z\\u{00a0}-\\u{ffff}]*"

  const regex = new RegExp (
    [
      "(&)",

      "(#".concat (identifier, ")"),

      "(\\.".concat (identifier, ")"),
      "(\\$".concat (identifier, ")"),
      "(%".concat (identifier, ")"),
      "(\\^".concat (identifier, ")"),
      "(\\[[-$*0-9=A-Z^_a-z|~\\u{00a0}-\\u{ffff}]+\\])",
      "(::?".concat (identifier, ")"),

      "(".concat (identifier, ")"),

      "(\\*)",

      "([ +>~]+)"
    ].join ("|"),
    "gu"
  )

  return selectors.split (",").map (function (selector) {
    return selector
      .trim ()
      .match (regex)
      .map (function (str) {
        return str.trim ().replace (/^$/u, " ")
      })
  })
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/build/get-selectors.test.js
import ava from "ava"
import { getSelectors } from "./get-selectors.js"

ava ("given undefined arguments", (t) => {
  t.throws (() => getSelectors ())
})

ava ("given a string with ancestor selector", (t) => {
  const actual = getSelectors ("&")
  const expect = [["&"]]

  t.deepEqual (actual, expect)
})

ava ("given a string with an id selector", (t) => {
  const actual = getSelectors ("#a")
  const expect = [["#a"]]

  t.deepEqual (actual, expect)
})

ava ("given a string with a class selector", (t) => {
  const actual = getSelectors (".a")
  const expect = [[".a"]]

  t.deepEqual (actual, expect)
})

ava ("given a string with a suffix selector", (t) => {
  const actual = getSelectors ("$a")
  const expect = [["$a"]]

  t.deepEqual (actual, expect)
})

ava ("given a string with a placeholder selector", (t) => {
  const actual = getSelectors ("%a")
  const expect = [["%a"]]

  t.deepEqual (actual, expect)
})

ava ("given a string with a prefix selector", (t) => {
  const actual = getSelectors ("^a")
  const expect = [["^a"]]

  t.deepEqual (actual, expect)
})

ava ("given a string with an attribute selector (1)", (t) => {
  const actual = getSelectors ("[a]")
  const expect = [["[a]"]]

  t.deepEqual (actual, expect)
})

ava ("given a string with an attribute selector (2)", (t) => {
  const actual = getSelectors ("[class=x]")
  const expect = [["[class=x]"]]

  t.deepEqual (actual, expect)
})

ava ("given a string with a pseudo-class selector", (t) => {
  const actual = getSelectors (":first-child")
  const expect = [[":first-child"]]

  t.deepEqual (actual, expect)
})

ava ("given a string with a pseudo-element selector", (t) => {
  const actual = getSelectors ("::after")
  const expect = [["::after"]]

  t.deepEqual (actual, expect)
})

ava ("given a string with a type selector", (t) => {
  const actual = getSelectors ("a")
  const expect = [["a"]]

  t.deepEqual (actual, expect)
})

ava ("given a string with a universal selector", (t) => {
  const actual = getSelectors ("*")
  const expect = [["*"]]

  t.deepEqual (actual, expect)
})

ava ("given a string with a complex selector", (t) => {
  const actual = getSelectors ("&#a.b%c[d]::after li ~ *")
  const expect = [
    ["&", "#a", ".b", "%c", "[d]", "::after", " ", "li", "~", "*"]
  ]

  t.deepEqual (actual, expect)
})

ava ("given a string with multiple complex selectors", (t) => {
  const actual = getSelectors ("& > div::hover, li[aria-expanded=true]")
  const expect = [
    ["&", ">", "div", "::hover"],
    ["li", "[aria-expanded=true]"]
  ]

  t.deepEqual (actual, expect)
})
#+end_src
#+HTML: </details>

**** getSelectorsString

#+HTML: <details>
#+begin_src js :tangle src/build/get-selectors-string.js
export function getSelectorsString (params = {}) {
  const selectors = params.selectors || []

  return selectors
    .map (function (selector) {
      return selector.join ("")
    })
    .join (",")
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/build/get-selectors-string.test.js
import ava from "ava"
import { getSelectorsString } from "./get-selectors-string.js"

ava ("given undefined arguments", (t) => {
  const actual = getSelectorsString ()

  const expect = ""

  t.is (actual, expect)
})

ava ("given an object with empty selectors (1)", (t) => {
  const actual = getSelectorsString ({
    "selectors": []
  })

  const expect = ""

  t.is (actual, expect)
})

ava ("given an object with empty selectors (2)", (t) => {
  const actual = getSelectorsString ({
    "selectors": [[]]
  })

  const expect = ""

  t.is (actual, expect)
})

ava ("given an object with single selector (1)", (t) => {
  const actual = getSelectorsString ({
    "selectors": [[".abcde"]]
  })

  const expect = ".abcde"

  t.is (actual, expect)
})

ava ("given an object with single selector (2)", (t) => {
  const actual = getSelectorsString ({
    "selectors": [[".abcde", ">", ".fghij"]]
  })

  const expect = ".abcde>.fghij"

  t.is (actual, expect)
})

ava ("given an object with multiple selectors (1)", (t) => {
  const actual = getSelectorsString ({
    "selectors": [[".abcde"], [".fghij"]]
  })

  const expect = ".abcde,.fghij"

  t.is (actual, expect)
})

ava ("given an object with multiple selectors (2)", (t) => {
  const actual = getSelectorsString ({
    "selectors": [[".abcde", ":hover"], [".fghij"]]
  })

  const expect = ".abcde:hover,.fghij"

  t.is (actual, expect)
})
#+end_src
#+HTML: </details>

**** getStringHash

#+HTML: <details>
#+begin_src js :tangle src/build/get-string-hash.js
/**
 * Converts `string` to unique hash identifier string.
 *
 * @param {string} string
 * - The string to convert.
 *
 * @returns {string}
 *   The string hash identifier.
 */

export function getStringHash (string = "") {
  return string
    .split ("")
    .reduce (function (i, str) {
      return i << 5 ^ i ^ str.charCodeAt () & 0xffffffffff
    }, 5381 << 2)
    .toString (36)
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/build/get-string-hash.test.js
import ava from "ava"
import { getStringHash } from "./get-string-hash.js"

ava ("given undefined arguments", (t) => {
  const actual = getStringHash ().slice (-3)
  const expect = "glw"

  t.is (actual, expect)
})

ava ("given an empty string", (t) => {
  const actual = getStringHash ("").slice (-3)
  const expect = "glw"

  t.is (actual, expect)
})

ava ("given a simple string (1)", (t) => {
  const actual = getStringHash ("abc").slice (-3)
  const expect = "ed0"

  t.is (actual, expect)
})

ava ("given a simple string (2)", (t) => {
  const actual = getStringHash ("abcd").slice (-3)
  const expect = "47k"

  t.is (actual, expect)
})
#+end_src
#+HTML: </details>

**** getStyle

#+HTML: <details>
#+begin_src js :tangle src/build/get-style.js
import { getBlockString, getSelectorsString, isDef } from "../api/index.js"

export function getStyle (params = {}, mq = false) {
  const media = mq && params.media
  const property = params.property

  return (/^%/u).test (property) || !isDef (property)
    ? null
    : "".concat (
      media ? "@media ".concat (media, "{") : "",
      getSelectorsString (params),
      "{",
      getBlockString (params),
      "}",
      media ? "}" : ""
    )
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/build/get-style.test.js
import ava from "ava"
import { getStyle } from "./get-style.js"

ava ("given undefined arguments", (t) => {
  const actual = getStyle ()
  const expect = null

  t.is (actual, expect)
})

ava ("given an object with valid params", (t) => {
  const actual = getStyle ({
    "block": [{ "background-color": "#f00" }],
    "property": "backgroundColor",
    "selectors": [[".jt2a9"]]
  })

  const expect = ".jt2a9{background-color:#f00}"

  t.is (actual, expect)
})

ava ("given an object with valid params and mq = true", (t) => {
  const actual = getStyle (
    {
      "block": [{ "background-color": "#f00" }],
      "property": "backgroundColor",
      "selectors": [[".jt2a9"]]
    },
    true
  )

  const expect = ".jt2a9{background-color:#f00}"

  t.is (actual, expect)
})

ava ("given an object with valid params and media", (t) => {
  const actual = getStyle ({
    "block": [{ "background-color": "#f00" }],
    "media": "(min-width: 768px)",
    "property": "backgroundColor",
    "selectors": [[".jt2a9"]]
  })

  const expect = ".jt2a9{background-color:#f00}"

  t.is (actual, expect)
})

ava ("given an object with valid params, media, mq = true", (t) => {
  const actual = getStyle (
    {
      "block": [{ "background-color": "#f00" }],
      "media": "(min-width: 768px)",
      "property": "backgroundColor",
      "selectors": [[".jt2a9"]]
    },
    true
  )

  const expect = "@media (min-width: 768px){.jt2a9{background-color:#f00}}"

  t.is (actual, expect)
})
#+end_src
#+HTML: </details>

**** getStyles

#+HTML: <details>
#+begin_src js :tangle src/build/get-styles.js
import { getStyle, store } from "../api/index.js"

export function getStyles () {
  let results = []

  store.forEach (function (rules, media) {
    let styles = []

    rules.forEach (function (style) {
      styles.push (getStyle (style))
    })

    styles = styles.sort ()

    if (media) {
      styles.unshift ("@media ".concat (media, "{"))
      styles.push ("}")
    }

    results = results.concat (styles)
  })

  return results.filter (Boolean).join ("")
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/build/get-styles.test.js
import ava from "ava"
import { css } from "../api/css.js"
import { cache } from "../store/cache.js"
import { getStyles } from "./get-styles.js"

ava.serial ("given undefined arguments", (t) => {
  const actual = getStyles ()
  const expect = ""

  t.is (actual, expect)
})

ava.serial ("given an object with placeholder property", (t) => {
  cache ({
    "block": [{ "%figure": true }],
    "emit": true,
    "identifier": "af3qz",
    "input": { "%figure": true },
    "media": "",
    "property": "%figure",
    "selectors": [],
    "value": true
  })

  const actual = getStyles ()

  const expect = ""

  t.is (actual, expect)
})

ava.serial ("given an object with simple property and value", (t) => {
  cache ({
    "block": [
      {
        "background-color": "#f00"
      }
    ],
    "identifier": "jt2a9",
    "property": "backgroundColor",
    "selectors": [[".jt2a9"]],
    "value": "#f00"
  })

  const actual = getStyles ()

  const expect = ".jt2a9{background-color:#f00}"

  t.is (actual, expect)
})

/* eslint-disable sort-keys */
ava.serial ("given a sample declaration", (t) => {
  css ({
    "backgroundColor": "#0f0",
    "@media (min-width: 768px)": {
      "backgroundColor": "#f00"
    }
  })

  const actual = getStyles ()

  const expect =
    ".jt2a9{background-color:#f00}.jtz4h{background-color:#0f0}@media (min-width: 768px){.jtdpi{background-color:#f00}}"

  t.is (actual, expect)
})
/* eslint-enable sort-keys */

ava.serial ("given an object with simple property and value (2)", (t) => {
  cache ({
    "block": [
      {
        "background-color": "#f00"
      }
    ],
    "emit": true,
    "identifier": "jtdzh",
    "input": {
      "background-color": "#f00"
    },
    "media": "",
    "property": "backgroundColor",
    "selectors": [[".jtdzh", ":hover"]],
    "value": "#f00"
  })

  const actual = getStyles ()

  const expect =
    ".jt2a9,.jtdzh:hover{background-color:#f00}.jtz4h{background-color:#0f0}@media (min-width: 768px){.jtdpi{background-color:#f00}}"

  t.is (actual, expect)
})
#+end_src
#+HTML: </details>

*** Client

**** canUseDom

#+HTML: <details>
#+begin_src js :tangle src/client/can-use-dom.js
/* istanbul ignore next */

/**
 * @returns {boolean}
 */

export const canUseDom = Boolean (
  typeof window !== "undefined" &&
    window.document &&
    window.document.createElement
)
#+end_src
#+HTML: </details>

**** getStyleElement

#+HTML: <details>
#+begin_src js :tangle src/client/get-style-element.js
/* istanbul ignore next */

export const getStyleElement = (function () {
  let styles

  return function (media = "") {
    if (typeof styles === "undefined") {
      styles = document.querySelectorAll ("style[data-creator='@amory/style']")
    }

    let style

    for (style of styles) {
      if (style.media === media) {
        return style
      }
    }

    style = document.createElement ("style")
    style.setAttribute ("data-creator", "@amory/style")

    if (media.length) {
      style.media = media
    }

    document.head.appendChild (style)

    styles = document.querySelectorAll ("style[data-creator='@amory/style']")

    return style
  }
}) ()
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/client/get-style-element.test.js
/* eslint-disable max-len */ /* global browser, page */

import ava from "ava"
import http from "http"
import puppeteer from "puppeteer"
import { getStyleElement } from "./get-style-element.js"

function httpContent (content = "") {
  return `<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><title></title>${content}</head></html>`
}

ava.before (async () => {
  http
    .createServer ((request, response) => {
      response.setHeader ("Content-type", "application/xhtml+xml")

      switch (request.url) {
        case "/a":
          return response.end (httpContent ())
        case "/b":
          return response.end (
            httpContent (
              `<style data-creator="@amory/style">.b{all:inherit}</style>`
            )
          )
        case "/c":
          return response.end (
            httpContent (
              `<style data-creator="@amory/style" media="(min-width: 768px)">.c{gap:1px}</style>`
            )
          )
      }

      return response.end ()
    })
    .listen (7000)

  global.browser = await puppeteer.launch ()
})

ava.beforeEach (async () => {
  global.page = await browser.newPage ()
})

ava.afterEach.always (async () => {
  await page.close ()
})

ava.after.always (async () => {
  await browser.close ()
})

ava.serial ("given URL '/a', verify returned contents (1)", async (t) => {
  await page.goto ("http://localhost:7000/a", { "waitUntil": "networkidle0" })

  const actual = await page.content ()

  const expect = httpContent ()

  t.is (actual, expect)
})

ava.serial ("given URL '/a', create a new style element (2)", async (t) => {
  await page.goto ("http://localhost:7000/a", { "waitUntil": "networkidle0" })

  const style = await page
    .evaluateHandle (getStyleElement)
    .then ((el) => el._remoteObject.className)

  const actual = await page.content ()

  const expect = httpContent (`<style data-creator="@amory/style"></style>`)

  t.is (style, "HTMLStyleElement")
  t.is (actual, expect)
})

ava.serial ("given URL '/a', create a new style element (3)", async (t) => {
  await page.goto ("http://localhost:7000/a", { "waitUntil": "networkidle0" })

  const style = await page
    .evaluateHandle (getStyleElement, "(min-width: 768px)")
    .then ((el) => el._remoteObject.className)

  const actual = await page.content ()

  const expect = httpContent (
    `<style data-creator="@amory/style" media="(min-width: 768px)"></style>`
  )

  t.is (style, "HTMLStyleElement")
  t.is (actual, expect)
})

ava.serial ("given URL '/b', verify returned contents (1)", async (t) => {
  await page.goto ("http://localhost:7000/b", { "waitUntil": "networkidle0" })

  const actual = await page.content ()

  const expect = httpContent (
    `<style data-creator="@amory/style">.b{all:inherit}</style>`
  )

  t.is (actual, expect)
})

ava.serial (
  "given URL '/b', should re-use existing style element (2)",
  async (t) => {
    await page.goto ("http://localhost:7000/b", { "waitUntil": "networkidle0" })

    const style = await page
      .evaluateHandle (getStyleElement)
      .then ((el) => el._remoteObject.className)

    const actual = await page.content ()

    const expect = httpContent (
      `<style data-creator="@amory/style">.b{all:inherit}</style>`
    )

    t.is (style, "HTMLStyleElement")
    t.is (actual, expect)
  }
)

ava.serial (
  "given URL '/b', should create additional style element (3)",
  async (t) => {
    await page.goto ("http://localhost:7000/b", { "waitUntil": "networkidle0" })

    const style = await page
      .evaluateHandle (getStyleElement, "(min-width: 768px)")
      .then ((el) => el._remoteObject.className)

    const actual = await page.content ()

    const expect = httpContent (
      /* eslint-disable-next-line max-len */
      `<style data-creator="@amory/style">.b{all:inherit}</style><style data-creator="@amory/style" media="(min-width: 768px)"></style>`
    )

    t.is (style, "HTMLStyleElement")
    t.is (actual, expect)
  }
)

ava.serial ("given URL '/c', verify returned contents (1)", async (t) => {
  await page.goto ("http://localhost:7000/c", { "waitUntil": "networkidle0" })

  const actual = await page.content ()

  const expect = httpContent (
    `<style data-creator="@amory/style" media="(min-width: 768px)">.c{gap:1px}</style>`
  )

  t.is (actual, expect)
})

ava.serial (
  "given URL '/c', should create additional style element (2)",
  async (t) => {
    await page.goto ("http://localhost:7000/c", { "waitUntil": "networkidle0" })

    const style = await page
      .evaluateHandle (getStyleElement)
      .then ((el) => el._remoteObject.className)

    const actual = await page.content ()

    const expect = httpContent (
      `<style data-creator="@amory/style" media="(min-width: 768px)">.c{gap:1px}</style><style data-creator="@amory/style"></style>`
    )

    t.is (style, "HTMLStyleElement")
    t.is (actual, expect)
  }
)

ava.serial (
  "given URL '/c', should re-use existing style element (3)",
  async (t) => {
    await page.goto ("http://localhost:7000/c", { "waitUntil": "networkidle0" })

    const style = await page
      .evaluateHandle (getStyleElement, "(min-width: 768px)")
      .then ((el) => el._remoteObject.className)

    const actual = await page.content ()

    const expect = httpContent (
      `<style data-creator="@amory/style" media="(min-width: 768px)">.c{gap:1px}</style>`
    )

    t.is (style, "HTMLStyleElement")
    t.is (actual, expect)
  }
)
/* eslint-enable max-len */
#+end_src
#+HTML: </details>

**** insertRule

#+HTML: <details>
#+begin_src js :tangle src/client/insert-rule.js
import { canUseDom, getStyle, getStyleElement, isDef } from "../api/index.js"

/* istanbul ignore next */

export function insertRule (params = {}) {
  if (canUseDom) {
    const sheet = getStyleElement ().sheet
    const style = getStyle (params, true)

    if (isDef (sheet) && style) {
      sheet.insertRule (style, sheet.cssRules.length)
    }
  }

  return params
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/client/insert-rule.test.js
import ava from "ava"
import { insertRule } from "./insert-rule.js"

ava ("given undefined arguments", (t) => {
  const actual = insertRule ()
  const expect = {}

  t.deepEqual (actual, expect)
})
#+end_src
#+HTML: </details>

**** update

#+begin_src js
store.forEach (function (_, media) {
  canUseDom &&
    window.requestAnimationFrame (function () {
      const styles = getStyles (media)

      const style = elements.has (media)
        ? elements.get (media)
        : getStyleElement (media)

      style.innerHTML = styles
      elements.set (media, style)
    })
})

return params
#+end_src

#+HTML: <details>
#+begin_src js :tangle src/client/update.js
import { canUseDom, insertRule, updateStyles } from "../api/index.js"

/* istanbul ignore next */

export function update (params = {}) {
  canUseDom && updateStyles ()

  return canUseDom ? insertRule (params) : params
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/client/update.test.js
import ava from "ava"
import { store } from "../store/store.js"
import { update } from "./update.js"

ava ("1", (t) => {
  store.set (
    "",
    new Map ([
      [
        '[{"background-color":"#f00"}]',
        {
          "block": [
            {
              "background-color": "#f00"
            }
          ],
          "emit": true,
          "identifier": "jt2a9",
          "input": {
            "background-color": "#f00"
          },
          "media": "",
          "property": "backgroundColor",
          "selectors": [[".jt2a9"]]
        }
      ],
      [
        '[{"display":"flex"},{"display":"grid"}]',
        {
          "block": [{ "display": "flex" }, { "display": "grid" }],
          "emit": true,
          "identifier": "dr7nz",
          "input": {
            "display": ["flex", "grid"]
          },
          "media": "",
          "property": "display",
          "selectors": [[".dr7nz"]]
        }
      ]
    ])
  )

  const actual = update ()

  const expect = {}

  t.deepEqual (actual, expect)
})

ava ("2", (t) => {
  store.set (
    "(min-width: 768px)",
    new Map ([
      [
        '[{"background-color":"#f00"}]',
        {
          "block": [
            {
              "background-color": "#f00"
            }
          ],
          "emit": true,
          "identifier": "jt2a9",
          "input": {
            "background-color": "#f00"
          },
          "media": "",
          "property": "backgroundColor",
          "selectors": [[".jt2a9"]]
        }
      ],
      [
        '[{"display":"flex"},{"display":"grid"}]',
        {
          "block": [{ "display": "flex" }, { "display": "grid" }],
          "emit": true,
          "identifier": "dr7nz",
          "input": {
            "display": ["flex", "grid"]
          },
          "media": "",
          "property": "display",
          "selectors": [[".dr7nz"]]
        }
      ]
    ])
  )

  const actual = update ()

  const expect = {}

  t.deepEqual (actual, expect)
})
#+end_src
#+HTML: </details>

**** updateStyles

#+HTML: <details>
#+begin_src js :tangle src/client/update-styles.js
import { debounce, getStyleElement, getStyles } from "../api/index.js"

/* istanbul ignore next */

export function updateStyles () {
  // export const updateStyles = debounce (function () {
  const style = getStyleElement ()
  const styles = getStyles ()

  style.innerHTML = styles

  // }, 25)
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/client/update-styles.test.js
import ava from "ava"

// import { updateStyles } from "./update-styles.js"

ava.todo ("todo")
#+end_src
#+HTML: </details>

*** Parse

**** parseFallbacks

#+HTML: <details>
#+begin_src js :tangle src/parse/parse-fallbacks.js
import { isObj, kebabCase, merge, parseFontFace } from "../api/index.js"

/* eslint-disable max-lines-per-function */
export function parseFallbacks (params = {}) {
  const value = params.value

  if (Array.isArray (value)) {
    const property = params.property

    let block = []
    const styles = []

    switch (property) {
      case "backgroundImage":
        block = [
          {
            [kebabCase (property)]: value.join (",")
          }
        ]
        break
      case "fontFamily":
        block = [
          {
            "font-family": value
              .reduce (function (fonts, font) {
                if (isObj (font)) {
                  const fontFace = parseFontFace ({
                    "property": property,
                    "value": font
                  }).shift ()

                  styles.push (fontFace)

                  return fonts.concat (fontFace.value)
                }

                return fonts.concat (font)
              }, [])
              .join (",")
          }
        ]
        break
      default:
        block = value.map (function (fallback) {
          return { [kebabCase (property)]: fallback }
        })
        break
    }

    return styles.concat (
      merge (
        params,
        {
          "block": null
        },
        {
          block
        }
      )
    )
  }

  return params
}
/* eslint-enable max-lines-per-function */
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/parse/parse-fallbacks.test.js
import ava from "ava"
import { parseFallbacks } from "./parse-fallbacks.js"

ava ("given undefined arguments", (t) => {
  const actual = parseFallbacks ()

  const expect = {}

  t.deepEqual (actual, expect)
})

ava (
  "given an object with backgroundImage property and array value (1)",
  (t) => {
    const actual = parseFallbacks ({
      "property": "backgroundImage",
      "value": [
        "url(https://mdn.mozillademos.org/files/11305/firefox.png)",
        "url(https://mdn.mozillademos.org/files/11307/bubbles.png)",
        "linear-gradient(to right, rgba(30, 75, 115, 1)",
        "rgba(255, 255, 255, 0))"
      ]
    })

    const expect = [
      {
        "block": [
          {
            "background-image":
              "url(https://mdn.mozillademos.org/files/11305/firefox.png),url(https://mdn.mozillademos.org/files/11307/bubbles.png),linear-gradient(to right, rgba(30, 75, 115, 1),rgba(255, 255, 255, 0))"
          }
        ],
        "property": "backgroundImage",
        "value": [
          "url(https://mdn.mozillademos.org/files/11305/firefox.png)",
          "url(https://mdn.mozillademos.org/files/11307/bubbles.png)",
          "linear-gradient(to right, rgba(30, 75, 115, 1)",
          "rgba(255, 255, 255, 0))"
        ]
      }
    ]

    t.deepEqual (actual, expect)
  }
)

/* eslint-disable max-lines-per-function */
ava ("given an object with fontFamily property and array value (1)", (t) => {
  const actual = parseFallbacks ({
    "property": "fontFamily",
    "value": [
      {
        "fontFamily": "Avenir",
        "src": "url('/fonts/avenir.woff') format('woff')"
      },
      "Helvetica",
      "Arial",
      {
        "src": "url('/fonts/font-2.woff') format('woff')"
      }
    ]
  })

  const expect = [
    {
      "block": [
        {
          "font-family": "Avenir"
        },
        {
          "src": "url('/fonts/avenir.woff') format('woff')"
        }
      ],
      "emit": false,
      "identifier": "c5lkw",
      "media": "",
      "property": "fontFamily",
      "selectors": [["@font-face"]],
      "value": "Avenir"
    },
    {
      "block": [
        {
          "src": "url('/fonts/font-2.woff') format('woff')"
        },
        {
          "font-family": "c53zz"
        }
      ],
      "emit": false,
      "identifier": "c53zz",
      "media": "",
      "property": "fontFamily",
      "selectors": [["@font-face"]],
      "value": "c53zz"
    },
    {
      "block": [
        {
          "font-family": "Avenir,Helvetica,Arial,c53zz"
        }
      ],
      "property": "fontFamily",
      "value": [
        {
          "fontFamily": "Avenir",
          "src": "url('/fonts/avenir.woff') format('woff')"
        },
        "Helvetica",
        "Arial",
        {
          "fontFamily": "c53zz",
          "src": "url('/fonts/font-2.woff') format('woff')"
        }
      ]
    }
  ]

  t.deepEqual (actual, expect)
})
/* eslint-enable max-lines-per-function */

ava ("given an object with display property and array value", (t) => {
  const actual = parseFallbacks ({
    "property": "display",
    "value": ["block", "flex", "grid"]
  })

  const expect = [
    {
      "block": [
        {
          "display": "block"
        },
        {
          "display": "flex"
        },
        {
          "display": "grid"
        }
      ],
      "property": "display",
      "value": ["block", "flex", "grid"]
    }
  ]

  t.deepEqual (actual, expect)
})
#+end_src
#+HTML: </details>

**** parseFontFace

#+HTML: <details>
#+begin_src js :tangle src/parse/parse-font-face.js
import {
  isArr,
  isObj,
  kebabCase,
  merge,
  parseIdentifier,
  toPairs
} from "../api/index.js"

export function parseFontFace (params = {}) {
  const property = params.property
  const value = params.value

  if (property === "fontFamily" && isObj (value) && !isArr (value)) {
    const media = params.media || ""

    const tmp = parseIdentifier (
      merge (params, { "selectors": null }, { "selectors": [["@font-face"]] })
    )

    const fontFamily =
      value.fontFamily || value["font-family"] || tmp.identifier

    value.fontFamily = fontFamily
    delete value["font-family"]

    return [
      merge (
        tmp,
        {
          "block": null
        },
        {
          "block": toPairs (value).reduce (function (styles, style) {
            return styles.concat ({ [kebabCase (style[0])]: style[1] })
          }, []),
          "emit": false,
          "media": "",
          "value": fontFamily
        }
      ),
      merge (
        tmp,
        { "block": null, "selectors": null },
        {
          "block": [{ "font-family": fontFamily }],
          "emit": true,
          "media": media,
          "selectors": [[".".concat (tmp.identifier)]],
          "value": fontFamily
        }
      )
    ]
  }

  return params
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/parse/parse-font-face.test.js
import ava from "ava"
import { parseFontFace } from "./parse-font-face.js"

ava ("given undefined arguments", (t) => {
  const actual = parseFontFace ()

  const expect = {}

  t.deepEqual (actual, expect)
})

ava ("given an object with valid font-face declaration (1)", (t) => {
  const actual = parseFontFace ({
    "property": "fontFamily",
    "value": {
      "src":
        "url('/fonts/font.woff2') format ('woff2'), url('/fonts/font.woff') format ('woff')"
    }
  })

  const expect = [
    {
      "block": [
        {
          "src":
            "url('/fonts/font.woff2') format ('woff2'), url('/fonts/font.woff') format ('woff')"
        },
        {
          "font-family": "c5xq1"
        }
      ],
      "emit": false,
      "identifier": "c5xq1",
      "media": "",
      "property": "fontFamily",
      "selectors": [["@font-face"]],
      "value": "c5xq1"
    },
    {
      "block": [
        {
          "font-family": "c5xq1"
        }
      ],
      "emit": true,
      "identifier": "c5xq1",
      "media": "",
      "property": "fontFamily",
      "selectors": [[".c5xq1"]],
      "value": "c5xq1"
    }
  ]

  t.deepEqual (actual, expect)
})

ava ("given an object with valid font-face declaration (2)", (t) => {
  const actual = parseFontFace ({
    "property": "fontFamily",
    "value": {
      "src":
        "url('/fonts/font2.woff2') format ('woff2'), url('/fonts/font2.woff') format ('woff')"
    }
  })

  const expect = [
    {
      "block": [
        {
          "src":
            "url('/fonts/font2.woff2') format ('woff2'), url('/fonts/font2.woff') format ('woff')"
        },
        {
          "font-family": "c5pnd"
        }
      ],
      "emit": false,
      "identifier": "c5pnd",
      "media": "",
      "property": "fontFamily",
      "selectors": [["@font-face"]],
      "value": "c5pnd"
    },
    {
      "block": [
        {
          "font-family": "c5pnd"
        }
      ],
      "emit": true,
      "identifier": "c5pnd",
      "media": "",
      "property": "fontFamily",
      "selectors": [[".c5pnd"]],
      "value": "c5pnd"
    }
  ]

  t.deepEqual (actual, expect)
})

/* eslint-disable max-lines-per-function */
ava ("given an object with valid font-face declaration (3)", (t) => {
  const actual = parseFontFace ({
    "property": "fontFamily",
    "value": {
      "fontFamily": "Avenir",
      "src":
        "url('/fonts/avenir.woff2') format ('woff2'), url('/fonts/avenir.woff') format ('woff')"
    }
  })

  const expect = [
    {
      "block": [
        {
          "font-family": "Avenir"
        },
        {
          "src":
            "url('/fonts/avenir.woff2') format ('woff2'), url('/fonts/avenir.woff') format ('woff')"
        }
      ],
      "emit": false,
      "identifier": "c5a4t",
      "media": "",
      "property": "fontFamily",
      "selectors": [["@font-face"]],
      "value": "Avenir"
    },
    {
      "block": [
        {
          "font-family": "Avenir"
        }
      ],
      "emit": true,
      "identifier": "c5a4t",
      "media": "",
      "property": "fontFamily",
      "selectors": [[".c5a4t"]],
      "value": "Avenir"
    }
  ]

  t.deepEqual (actual, expect)
})
/* eslint-enable max-lines-per-function */
#+end_src
#+HTML: </details>

**** parseIdentifier

#+HTML: <details>
#+begin_src js :tangle src/parse/parse-identifier.js
import { getPropertyId, getStringHash, isDef, merge } from "../api/index.js"

export function parseIdentifier (params = {}) {
  if (params.property) {
    const media = params.media || ""
    const property = params.property
    const value = params.value

    let selectors = params.selectors || []

    const identifier = isDef (params.identifier)
      ? params.identifier
      : getPropertyId (property).toString (36) +
        getStringHash (
          ""
            .concat (media)
            .concat (
              selectors
                .map (function (selector) {
                  return selector.join ("")
                })
                .join (",")
            )
            .concat (JSON.stringify (value))
        ).slice (-3)

    selectors =
      selectors.length || (/^%/u).test (property)
        ? selectors.map (function (selector) {
          return (/^:/u).test (selector[0])
            ? [].concat (".".concat (identifier), selector)
            : selector
        })
        : selectors.concat ([[".".concat (identifier)]])

    return merge (params, { "selectors": null }, { identifier, selectors })
  }

  return params
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/parse/parse-identifier.test.js
import ava from "ava"
import { parseIdentifier } from "./parse-identifier.js"

ava ("given undefined arguments", (t) => {
  const actual = parseIdentifier ()
  const expect = {}

  t.deepEqual (actual, expect)
})

ava ("given an object with undefined identifier (1)", (t) => {
  const actual = parseIdentifier ({
    "property": "backgroundColor",
    "value": "#f00"
  })

  const expect = {
    "identifier": "jt2a9",
    "property": "backgroundColor",
    "selectors": [[".jt2a9"]],
    "value": "#f00"
  }

  t.deepEqual (actual, expect)
})

ava ("given an object with undefined identifier (2)", (t) => {
  const actual = parseIdentifier ({
    "property": "backgroundColor",
    "value": "#0f0"
  })

  const expect = {
    "identifier": "jtz4h",
    "property": "backgroundColor",
    "selectors": [[".jtz4h"]],
    "value": "#0f0"
  }

  t.deepEqual (actual, expect)
})

ava ("given an object with undefined identifier (3)", (t) => {
  const actual = parseIdentifier ({
    "property": "color",
    "value": "#0f0"
  })

  const expect = {
    "identifier": "jkz4h",
    "property": "color",
    "selectors": [[".jkz4h"]],
    "value": "#0f0"
  }

  t.deepEqual (actual, expect)
})

ava ("given an object with undefined identifier and media (1)", (t) => {
  const actual = parseIdentifier ({
    "media": "(max-width: 767px)",
    "property": "color",
    "value": "#0f0"
  })

  const expect = {
    "identifier": "jkmmt",
    "media": "(max-width: 767px)",
    "property": "color",
    "selectors": [[".jkmmt"]],
    "value": "#0f0"
  }

  t.deepEqual (actual, expect)
})

ava ("given an object with undefined identifier and media (2)", (t) => {
  const actual = parseIdentifier ({
    "media": "(min-width: 768px)",
    "property": "color",
    "value": "#0f0"
  })

  const expect = {
    "identifier": "jkduu",
    "media": "(min-width: 768px)",
    "property": "color",
    "selectors": [[".jkduu"]],
    "value": "#0f0"
  }

  t.deepEqual (actual, expect)
})

ava ("given an object with undefined identifier and selectors (1)", (t) => {
  const actual = parseIdentifier ({
    "property": "color",
    "selectors": [[":active"]],
    "value": "#0f0"
  })

  const expect = {
    "identifier": "jkk07",
    "property": "color",
    "selectors": [[".jkk07", ":active"]],
    "value": "#0f0"
  }

  t.deepEqual (actual, expect)
})

ava ("given an object with undefined identifier and selectors (2)", (t) => {
  const actual = parseIdentifier ({
    "property": "color",
    "selectors": [[":hover"]],
    "value": "#0f0"
  })

  const expect = {
    "identifier": "jkgwd",
    "property": "color",
    "selectors": [[".jkgwd", ":hover"]],
    "value": "#0f0"
  }

  t.deepEqual (actual, expect)
})

ava (
  "given an object with undefined identifier, media, and selectors",
  (t) => {
    const actual = parseIdentifier ({
      "media": "(min-width: 768px)",
      "property": "color",
      "selectors": [[":hover"]],
      "value": "#0f0"
    })

    const expect = {
      "identifier": "jkda2",
      "media": "(min-width: 768px)",
      "property": "color",
      "selectors": [[".jkda2", ":hover"]],
      "value": "#0f0"
    }

    t.deepEqual (actual, expect)
  }
)

ava ("given an object with undefined identifier with selectors", (t) => {
  const actual = parseIdentifier ({
    "property": "background-color",
    "selectors": [[".abcde"]],
    "value": "#f00"
  })

  const expect = {
    "identifier": "jt5lu",
    "property": "background-color",
    "selectors": [[".abcde"]],
    "value": "#f00"
  }

  t.deepEqual (actual, expect)
})

ava ("given an object with defined identifier", (t) => {
  const actual = parseIdentifier ({
    "identifier": "abcde",
    "property": "background-color",
    "value": "#f00"
  })

  const expect = {
    "identifier": "abcde",
    "property": "background-color",
    "selectors": [[".abcde"]],
    "value": "#f00"
  }

  t.deepEqual (actual, expect)
})

ava ("given an object with valid camel-case property and value", (t) => {
  const actual = parseIdentifier ({
    "property": "backgroundColor",
    "value": "#000"
  })

  const expect = {
    "identifier": "jt37r",
    "property": "backgroundColor",
    "selectors": [[".jt37r"]],
    "value": "#000"
  }

  t.deepEqual (actual, expect)
})

ava ("given an object with valid kebab-case property and value", (t) => {
  const actual = parseIdentifier ({
    "property": "background-color",
    "value": "#000"
  })

  const expect = {
    "identifier": "jt37r",
    "property": "background-color",
    "selectors": [[".jt37r"]],
    "value": "#000"
  }

  t.deepEqual (actual, expect)
})

ava ("given an object with valid property, value, and selectors", (t) => {
  const actual = parseIdentifier ({
    "property": "background-color",
    "selectors": [[":hover"]],
    "value": "#000"
  })

  const expect = {
    "identifier": "jta6z",
    "property": "background-color",
    "selectors": [[".jta6z", ":hover"]],
    "value": "#000"
  }

  t.deepEqual (actual, expect)
})

ava ("given an object with valid property, value, and media", (t) => {
  const actual = parseIdentifier ({
    "media": "(min-width: 768px)",
    "property": "background-color",
    "value": "#000"
  })

  const expect = {
    "identifier": "jt0ac",
    "media": "(min-width: 768px)",
    "property": "background-color",
    "selectors": [[".jt0ac"]],
    "value": "#000"
  }

  t.deepEqual (actual, expect)
})

ava (
  "given an object with valid property, value, media, and selectors",
  (t) => {
    const actual = parseIdentifier ({
      "media": "(min-width: 768px)",
      "property": "background-color",
      "selectors": [[":hover"]],
      "value": "#000"
    })

    const expect = {
      "identifier": "jtdo0",
      "media": "(min-width: 768px)",
      "property": "background-color",
      "selectors": [[".jtdo0", ":hover"]],
      "value": "#000"
    }

    t.deepEqual (actual, expect)
  }
)
#+end_src
#+HTML: </details>

**** parseInput

#+HTML: <details>
#+begin_src js :tangle src/parse/parse-input.js
import { camelCase, isDef, kebabCase, toPairs } from "../api/index.js"

export function parseInput (params = {}) {
  const emit = isDef (params.emit) ? params.emit : true
  const input = params.input || {}
  const media = params.media || ""
  const selectors = params.selectors || []

  return toPairs (input).reduce (function (styles, style) {
    const property = style[0]
    const value = style[1]

    return styles.concat ({
      "block": [
        {
          [kebabCase (property)]: value
        }
      ],
      "emit": emit,
      "input": {
        [property]: value
      },
      "media": media,
      "property": camelCase (property),
      "selectors": selectors,
      "value": value
    })
  }, [])
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/parse/parse-input.test.js
import ava from "ava"
import { parseInput } from "./parse-input.js"

ava ("given undefined arguments", (t) => {
  const actual = parseInput ()
  const expect = []

  t.deepEqual (actual, expect)
})

ava ("given an object with multiple properties and values", (t) => {
  const actual = parseInput ({
    "input": {
      "backgroundColor": "#f00",
      "display": "block"
    }
  })

  const expect = [
    {
      "block": [
        {
          "background-color": "#f00"
        }
      ],
      "emit": true,
      "input": {
        "backgroundColor": "#f00"
      },
      "media": "",
      "property": "backgroundColor",
      "selectors": [],
      "value": "#f00"
    },
    {
      "block": [
        {
          "display": "block"
        }
      ],
      "emit": true,
      "input": {
        "display": "block"
      },
      "media": "",
      "property": "display",
      "selectors": [],
      "value": "block"
    }
  ]

  t.deepEqual (actual, expect)
})
#+end_src
#+HTML: </details>

**** parseKeyframes

#+HTML: <details>
#+begin_src js :tangle src/parse/parse-keyframes.js
import {
  isObj,
  kebabCase,
  merge,
  parseIdentifier,
  toPairs
} from "../api/index.js"

export function parseKeyframes (params = {}) {
  const property = params.property
  const value = params.value

  if (property === "animationName" && isObj (value)) {
    const media = params.media || ""

    const tmp = parseIdentifier (
      merge (params, { "selectors": null }, { "selectors": [["@keyframes", " "]] })
    )

    const animationName = tmp.identifier

    return [
      merge (
        tmp,
        { "block": null, "selectors": null },
        {
          "block": toPairs (value).reduce (function (styles, style) {
            return styles.concat ({ [kebabCase (style[0])]: style[1] })
          }, []),
          "emit": false,
          "media": "",
          "selectors": [tmp.selectors[0].concat (animationName)],
          "value": animationName
        }
      ),
      merge (
        tmp,
        { "block": null, "selectors": null },
        {
          "block": [{ "animation-name": animationName }],
          "emit": true,
          "media": media,
          "selectors": [[".".concat (animationName)]],
          "value": animationName
        }
      )
    ]
  }

  return params
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/parse/parse-keyframes.test.js
import ava from "ava"
import { parseKeyframes } from "./parse-keyframes.js"

ava ("given undefined arguments", (t) => {
  const actual = parseKeyframes ()

  const expect = {}

  t.deepEqual (actual, expect)
})

ava ("given an object with valid keyframes declaration (1)", (t) => {
  const actual = parseKeyframes ({
    "property": "animationName",
    "value": {
      "0%": {
        "opacity": 0
      },
      "100%": {
        "opacity": 1
      }
    }
  })

  const expect = [
    {
      "block": [{ "0%": { "opacity": 0 } }, { "100%": { "opacity": 1 } }],
      "emit": false,
      "identifier": "m7okn",
      "media": "",
      "property": "animationName",
      "selectors": [["@keyframes", " ", "m7okn"]],
      "value": "m7okn"
    },
    {
      "block": [{ "animation-name": "m7okn" }],
      "emit": true,
      "identifier": "m7okn",
      "media": "",
      "property": "animationName",
      "selectors": [[".m7okn"]],
      "value": "m7okn"
    }
  ]

  t.deepEqual (actual, expect)
})

ava ("given an object with valid keyframes declaration (2)", (t) => {
  const actual = parseKeyframes ({
    "property": "animationName",
    "value": {
      "0%": {
        "opacity": 1
      },
      "100%": {
        "opacity": 0
      }
    }
  })

  const expect = [
    {
      "block": [{ "0%": { "opacity": 1 } }, { "100%": { "opacity": 0 } }],
      "emit": false,
      "identifier": "m7nlz",
      "media": "",
      "property": "animationName",
      "selectors": [["@keyframes", " ", "m7nlz"]],
      "value": "m7nlz"
    },
    {
      "block": [
        {
          "animation-name": "m7nlz"
        }
      ],
      "emit": true,
      "identifier": "m7nlz",
      "media": "",
      "property": "animationName",
      "selectors": [[".m7nlz"]],
      "value": "m7nlz"
    }
  ]

  t.deepEqual (actual, expect)
})
#+end_src
#+HTML: </details>

**** parseMedia

#+HTML: <details>
#+begin_src js :tangle src/parse/parse-media.js
import { isObj, kebabCase, parse } from "../api/index.js"

export function parseMedia (params = {}) {
  const property = params.property
  const value = params.value

  if ((/^@media/u).test (property) && isObj (value)) {
    const media = [params.media, kebabCase (property.slice (6).trim ())]
      .filter (Boolean)
      .join (" and ")

    return parse ({ "input": value, media })
  }

  return params
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/parse/parse-media.test.js
import ava from "ava"
import { parseMedia } from "./parse-media.js"

ava ("given undefined arguments", (t) => {
  const actual = parseMedia ()

  const expect = {}

  t.deepEqual (actual, expect)
})

ava ("given an object with valid media declaration", (t) => {
  const actual = parseMedia ({
    "property": "@media (min-width: 768px)",
    "value": {
      "background-color": "#000"
    }
  })

  const expect = [
    {
      "block": [
        {
          "background-color": "#000"
        }
      ],
      "emit": true,
      "identifier": "jt0ac",
      "input": {
        "background-color": "#000"
      },
      "media": "(min-width: 768px)",
      "property": "backgroundColor",
      "selectors": [[".jt0ac"]],
      "value": "#000"
    }
  ]

  t.deepEqual (actual, expect)
})

ava ("given an object with complex valid media declaration", (t) => {
  const actual = parseMedia ({
    "property": "@media (min-width: 768px)",
    "value": {
      "@media (-webkit-min-device-pixel-ratio: 2)": {
        "background-color": "#000"
      }
    }
  })

  const expect = [
    {
      "block": [
        {
          "background-color": "#000"
        }
      ],
      "emit": true,
      "identifier": "jtnzy",
      "input": {
        "background-color": "#000"
      },
      "media": "(min-width: 768px) and (-webkit-min-device-pixel-ratio: 2)",
      "property": "backgroundColor",
      "selectors": [[".jtnzy"]],
      "value": "#000"
    }
  ]

  t.deepEqual (actual, expect)
})
#+end_src
#+HTML: </details>

**** parseNumbers

#+HTML: <details>
#+begin_src js :tangle src/parse/parse-numbers.js
import { isNum, kebabCase, merge } from "../api/index.js"

export function parseNumbers (params = {}) {
  const property = params.property
  let value = params.value

  /* eslint-disable-next-line max-len */
  const regex = /(animationIterationCount|borderImage(?:Outset|Slice|Width)|box(?:(?:Flex)(?:Group)?|OrdinalGroup)|column(?:Count|s)|fillOpacity|floodOpacity|stopOpacity|stroke(?:Dash(?:array|offset)|Miterlimit|Opacity|Width)|flex(?:Grow|Positive|Shrink|Negative|Order)?\b|grid(?:Area|Column(?:End|Start)?|Row(?:End|Start)?)|fontWeight|line(?:Clamp|Height)|opacity|\border|orphans|tabSize|widows|zIndex|zoom)/u

  if (!regex.test (property) && isNum (value) && value !== 0) {
    value = "".concat (value, "px")

    return merge (
      params,
      { "block": null },
      { "block": [{ [kebabCase (property)]: value }], value }
    )
  }

  return params
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/parse/parse-numbers.test.js
import ava from "ava"
import { parseNumbers } from "./parse-numbers.js"

ava ("given undefined arguments", (t) => {
  const actual = parseNumbers ()

  const expect = {}

  t.deepEqual (actual, expect)
})

ava ("given an object with 'margin' property and integer value (1)", (t) => {
  const actual = parseNumbers ({
    "property": "margin",
    "value": 10
  })

  const expect = {
    "block": [{ "margin": "10px" }],
    "property": "margin",
    "value": "10px"
  }

  t.deepEqual (actual, expect)
})

ava ("given an object with 'margin' property and integer value (2)", (t) => {
  const actual = parseNumbers ({
    "property": "margin",
    "value": 0
  })

  const expect = {
    "property": "margin",
    "value": 0
  }

  t.deepEqual (actual, expect)
})

ava ("given an object with 'order' property and integer values", (t) => {
  const actual = parseNumbers ({
    "property": "order",
    "value": 10
  })

  const expect = {
    "property": "order",
    "value": 10
  }

  t.deepEqual (actual, expect)
})
#+end_src
#+HTML: </details>

**** parsePlaceholder

#+HTML: <details>
#+begin_src js :tangle src/parse/parse-placeholder.js
import { merge, parseIdentifier } from "../api/index.js"

export function parsePlaceholder (params = {}) {
  const property = params.property
  const value = params.value

  if ((/^%/u).test (property) && value === true) {
    return merge (params, {
      "identifier": parseIdentifier ({
        "media": params.media,
        property,
        "value": property
      }).identifier
    })
  }

  return params
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/parse/parse-placeholder.test.js
import ava from "ava"
import { parsePlaceholder } from "./parse-placeholder.js"

ava ("given undefined arguments", (t) => {
  const actual = parsePlaceholder ()

  const expect = {}

  t.deepEqual (actual, expect)
})

ava ("given an object with valid placeholder (1)", (t) => {
  const actual = parsePlaceholder ({
    "property": "%figure",
    "value": true
  })

  const expect = {
    "identifier": "af3qz",
    "property": "%figure",
    "value": true
  }

  t.deepEqual (actual, expect)
})

ava ("given an object with valid placeholder (2)", (t) => {
  const actual = parsePlaceholder ({
    "property": "%stuff",
    "value": true
  })

  const expect = {
    "identifier": "afdkz",
    "property": "%stuff",
    "value": true
  }

  t.deepEqual (actual, expect)
})

ava ("given an object without a placeholder", (t) => {
  const actual = parsePlaceholder ({
    "property": "%stuff",
    "value": {
      "backgroundColor": "#f00"
    }
  })

  const expect = {
    "property": "%stuff",
    "value": {
      "backgroundColor": "#f00"
    }
  }

  t.deepEqual (actual, expect)
})
#+end_src
#+HTML: </details>

**** parseSelectors

#+HTML: <details>
#+begin_src js :tangle src/parse/parse-selectors.js
import {
  getAncestors,
  getPlaceholders,
  getSelectors,
  isObj,
  kebabCase,
  parse
} from "../api/index.js"

export function parseSelectors (params = {}) {
  const property = params.property
  const value = params.value

  if ((/([#$%&*+,.>[^~]|:[a-z])/u).test (property) && isObj (value)) {
    const emit = (/^:/u).test (property)

    const selectors = getSelectors (kebabCase (property))
      .reduce (function (a, b) {
        return a.concat (getAncestors (params.selectors, [b]))
      }, [])
      .reduce (function (a, b) {
        return a.concat ([getPlaceholders (b)])
      }, [])

    return parse ({ emit, "input": value, "media": params.media, selectors })
  }

  return params
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/parse/parse-selectors.test.js
import ava from "ava"
import { parsePlaceholder } from "./parse-placeholder.js"
import { parseSelectors } from "./parse-selectors.js"

ava ("given undefined arguments", (t) => {
  const actual = parseSelectors ()

  const expect = {}

  t.deepEqual (actual, expect)
})

/* eslint-disable max-lines-per-function */
ava ("given an object with valid selectors", (t) => {
  const actual = parseSelectors ({
    "property": "#root %stuff",
    "value": {
      "#products::after,%figure > &,#body~&+stuff": {
        "background-color": "#f0f",
        "display": "grid"
      }
    }
  })

  const expect = [
    {
      "block": [
        {
          "background-color": "#f0f"
        }
      ],
      "emit": false,
      "identifier": "jtj6u",
      "input": {
        "background-color": "#f0f"
      },
      "media": "",
      "property": "backgroundColor",
      "selectors": [
        ["#root", " ", ".afdkz", " ", "#products", "::after"],
        [".af3qz", ">", "#root", " ", ".afdkz"],
        ["#body", "~", "#root", " ", ".afdkz", "+", "stuff"]
      ],
      "value": "#f0f"
    },
    {
      "block": [
        {
          "display": "grid"
        }
      ],
      "emit": false,
      "identifier": "draen",
      "input": {
        "display": "grid"
      },
      "media": "",
      "property": "display",
      "selectors": [
        ["#root", " ", ".afdkz", " ", "#products", "::after"],
        [".af3qz", ">", "#root", " ", ".afdkz"],
        ["#body", "~", "#root", " ", ".afdkz", "+", "stuff"]
      ],
      "value": "grid"
    }
  ]

  t.deepEqual (actual, expect)
})
/* eslint-enable max-lines-per-function */

ava ("given an object with valid property and value", (t) => {
  const actual = parseSelectors ({
    "property": "@media (max-width: 767px)",
    "value": {
      "background-color": "#f0f"
    }
  })

  const expect = {
    "property": "@media (max-width: 767px)",
    "value": {
      "background-color": "#f0f"
    }
  }

  t.deepEqual (actual, expect)
})

ava ("given an object with valid pseudo-class selector", (t) => {
  const actual = parseSelectors ({
    "property": ":hover",
    "value": {
      "font-family": "Helvetica"
    }
  })

  const expect = [
    {
      "block": [
        {
          "font-family": "Helvetica"
        }
      ],
      "emit": true,
      "identifier": "c53hh",
      "input": {
        "font-family": "Helvetica"
      },
      "media": "",
      "property": "fontFamily",
      "selectors": [[".c53hh", ":hover"]],
      "value": "Helvetica"
    }
  ]

  t.deepEqual (actual, expect)
})

ava ("given an object with valid attribute selector", (t) => {
  const actual = parseSelectors ({
    "property": "[aria-expanded=true]",
    "value": {
      "backgroundColor": "#f00"
    }
  })

  const expect = [
    {
      "block": [{ "background-color": "#f00" }],
      "emit": false,
      "identifier": "jtrn7",
      "input": { "backgroundColor": "#f00" },
      "media": "",
      "property": "backgroundColor",
      "selectors": [["[aria-expanded=true]"]],
      "value": "#f00"
    }
  ]

  t.deepEqual (actual, expect)
})

ava ("given an object with valid placeholder selector", (t) => {
  const actual = parsePlaceholder ({
    "property": "%fieldset",
    "value": true
  })

  const expect = {
    "identifier": "afvip",
    "property": "%fieldset",
    "value": true
  }

  t.deepEqual (actual, expect)
})

ava ("given an object with valid placeholder selector (2)", (t) => {
  const actual = parseSelectors ({
    "property": "%fieldset",
    "value": {
      "&[aria-expanded=true]": {
        "backgroundColor": "#f00"
      }
    }
  })

  const expect = [
    {
      "block": [{ "background-color": "#f00" }],
      "emit": false,
      "identifier": "jt8ph",
      "input": { "backgroundColor": "#f00" },
      "media": "",
      "property": "backgroundColor",
      "selectors": [[".afvip", "[aria-expanded=true]"]],
      "value": "#f00"
    }
  ]

  t.deepEqual (actual, expect)
})

ava ("given an object with valid placeholder with attribute selector", (t) => {
  const actual = parseSelectors ({
    "property": "%fieldset[aria-expanded=true]",
    "value": {
      "backgroundColor": "#f00"
    }
  })

  const expect = [
    {
      "block": [{ "background-color": "#f00" }],
      "emit": false,
      "identifier": "jt8ph",
      "input": { "backgroundColor": "#f00" },
      "media": "",
      "property": "backgroundColor",
      "selectors": [[".afvip", "[aria-expanded=true]"]],
      "value": "#f00"
    }
  ]

  t.deepEqual (actual, expect)
})
#+end_src
#+HTML: </details>

**** parseTypeSelector

#+HTML: <details>
#+begin_src js :tangle src/parse/parse-type-selector.js
import { isArr, isObj, parse } from "../api/index.js"

export function parseTypeSelector (params = {}) {
  const property = params.property
  const value = params.value

  if ((/^([a-z]+)$/u).test (property) && isObj (value) && !isArr (value)) {
    return parse ({
      "emit": false,
      "input": value,
      "media": params.media,
      "selectors": [[property]]
    })
  }

  return params
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/parse/parse-type-selector.test.js
import ava from "ava"
import { parseTypeSelector } from "./parse-type-selector.js"

ava ("given undefined arguments", (t) => {
  const actual = parseTypeSelector ()

  const expect = {}

  t.deepEqual (actual, expect)
})

ava ("given an object with bare element selector", (t) => {
  const actual = parseTypeSelector ({
    "property": "body",
    "value": {
      "backgroundColor": "#f00"
    }
  })

  const expect = [
    {
      "block": [{ "background-color": "#f00" }],
      "emit": false,
      "identifier": "jtem7",
      "input": { "backgroundColor": "#f00" },
      "media": "",
      "property": "backgroundColor",
      "selectors": [["body"]],
      "value": "#f00"
    }
  ]

  t.deepEqual (actual, expect)
})
#+end_src
#+HTML: </details>

**** parse

#+HTML: <details>
#+begin_src js :tangle src/parse/parse.js
import {
  parseFallbacks,
  parseFontFace,
  parseIdentifier,
  parseInput,
  parseKeyframes,
  parseMedia,
  parseNumbers,
  parsePlaceholder,
  parseSelectors,
  parseTypeSelector
} from "../api/index.js"

export function parse (params = {}) {
  return parseInput (params)
    .reduce (function (styles, style) {
      return styles.concat (parseNumbers (style))
    }, [])
    .reduce (function (styles, style) {
      return styles.concat (parseMedia (style))
    }, [])
    .reduce (function (styles, style) {
      return styles.concat (parsePlaceholder (style))
    }, [])
    .reduce (function (styles, style) {
      return styles.concat (parseSelectors (style))
    }, [])
    .reduce (function (styles, style) {
      return styles.concat (parseIdentifier (style))
    }, [])
    .reduce (function (styles, style) {
      return styles.concat (parseFallbacks (style))
    }, [])
    .reduce (function (styles, style) {
      return styles.concat (parseFontFace (style))
    }, [])
    .reduce (function (styles, style) {
      return styles.concat (parseKeyframes (style))
    }, [])
    .reduce (function (styles, style) {
      return styles.concat (parseTypeSelector (style))
    }, [])
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/parse/parse.test.js
import ava from "ava"
import { parse } from "./parse.js"

ava ("given undefined arguments", (t) => {
  const actual = parse ()

  const expect = []

  t.deepEqual (actual, expect)
})

ava ("given an object with valid property and value", (t) => {
  const actual = parse ({
    "input": {
      "background-color": "#f00",
      "display": "block"
    }
  })

  const expect = [
    {
      "block": [
        {
          "background-color": "#f00"
        }
      ],
      "emit": true,
      "identifier": "jt2a9",
      "input": {
        "background-color": "#f00"
      },
      "media": "",
      "property": "backgroundColor",
      "selectors": [[".jt2a9"]],
      "value": "#f00"
    },
    {
      "block": [
        {
          "display": "block"
        }
      ],
      "emit": true,
      "identifier": "drtx9",
      "input": {
        "display": "block"
      },
      "media": "",
      "property": "display",
      "selectors": [[".drtx9"]],
      "value": "block"
    }
  ]

  t.deepEqual (actual, expect)
})

/* eslint-disable max-lines-per-function */
ava ("given an object with a media declaration", (t) => {
  /* eslint-disable sort-keys */
  const actual = parse ({
    "input": {
      "@media (min-width: 768px)": {
        "color": "#f00",
        "fontFamily": "sans-serif",
        "@media screen": {
          "backgroundColor": ["rgba(0, 0, 0, 0.9)", "#111"]
        }
      }
    }
  })
  /* eslint-enable sort-keys */

  const expect = [
    {
      "block": [
        {
          "color": "#f00"
        }
      ],
      "emit": true,
      "identifier": "jkdpi",
      "input": {
        "color": "#f00"
      },
      "media": "(min-width: 768px)",
      "property": "color",
      "selectors": [[".jkdpi"]],
      "value": "#f00"
    },
    {
      "block": [
        {
          "font-family": "sans-serif"
        }
      ],
      "emit": true,
      "identifier": "c5r5i",
      "input": {
        "fontFamily": "sans-serif"
      },
      "media": "(min-width: 768px)",
      "property": "fontFamily",
      "selectors": [[".c5r5i"]],
      "value": "sans-serif"
    },
    {
      "block": [
        {
          "background-color": "rgba(0, 0, 0, 0.9)"
        },
        {
          "background-color": "#111"
        }
      ],
      "emit": true,
      "identifier": "jtne4",
      "input": {
        "backgroundColor": ["rgba(0, 0, 0, 0.9)", "#111"]
      },
      "media": "(min-width: 768px) and screen",
      "property": "backgroundColor",
      "selectors": [[".jtne4"]],
      "value": ["rgba(0, 0, 0, 0.9)", "#111"]
    }
  ]

  t.deepEqual (actual, expect)
})

ava ("given an object with a complex fontFamily declaration", (t) => {
  const actual = parse ({
    "input": {
      "fontFamily": [
        {
          "fontFamily": "Avenir",
          "src":
            "url('/fonts/avenir.woff2') format ('woff2'), url('/fonts/avenir.woff') format ('woff')"
        },
        {
          "src": "url('/fonts/font.woff2') format ('woff2')"
        },
        "sans-serif"
      ]
    }
  })

  const expect = [
    {
      "block": [
        {
          "font-family": "Avenir"
        },
        {
          "src":
            "url('/fonts/avenir.woff2') format ('woff2'), url('/fonts/avenir.woff') format ('woff')"
        }
      ],
      "emit": false,
      "identifier": "c5a4t",
      "media": "",
      "property": "fontFamily",
      "selectors": [["@font-face"]],
      "value": "Avenir"
    },
    {
      "block": [
        {
          "src": "url('/fonts/font.woff2') format ('woff2')"
        },
        {
          "font-family": "c5z34"
        }
      ],
      "emit": false,
      "identifier": "c5z34",
      "media": "",
      "property": "fontFamily",
      "selectors": [["@font-face"]],
      "value": "c5z34"
    },
    {
      "block": [
        {
          "font-family": "Avenir,c5z34,sans-serif"
        }
      ],
      "emit": true,
      "identifier": "c5mvq",
      "input": {
        "fontFamily": [
          {
            "fontFamily": "Avenir",
            "src":
              "url('/fonts/avenir.woff2') format ('woff2'), url('/fonts/avenir.woff') format ('woff')"
          },
          {
            "src": "url('/fonts/font.woff2') format ('woff2')"
          },
          "sans-serif"
        ]
      },
      "media": "",
      "property": "fontFamily",
      "selectors": [[".c5mvq"]],
      "value": [
        {
          "fontFamily": "Avenir",
          "src":
            "url('/fonts/avenir.woff2') format ('woff2'), url('/fonts/avenir.woff') format ('woff')"
        },
        {
          "fontFamily": "c5z34",
          "src": "url('/fonts/font.woff2') format ('woff2')"
        },
        "sans-serif"
      ]
    }
  ]

  t.deepEqual (actual, expect)
})

ava ("given an object with a complex keyframes declaration", (t) => {
  /* eslint-disable sort-keys */
  const actual = parse ({
    "input": {
      "animationName": "slide-left",
      "@media (min-width: 768px)": {
        "animationName": {
          "0%": {
            "opacity": 0
          },
          "100%": {
            "opacity": 1
          }
        }
      }
    }
  })
  /* eslint-enable sort-keys */

  const expect = [
    {
      "block": [
        {
          "animation-name": "slide-left"
        }
      ],
      "emit": true,
      "identifier": "m757v",
      "input": {
        "animationName": "slide-left"
      },
      "media": "",
      "property": "animationName",
      "selectors": [[".m757v"]],
      "value": "slide-left"
    },
    {
      "block": [
        {
          "0%": {
            "opacity": 0
          }
        },
        {
          "100%": {
            "opacity": 1
          }
        }
      ],
      "emit": false,
      "identifier": "m7cxh",
      "input": {
        "animationName": {
          "0%": {
            "opacity": 0
          },
          "100%": {
            "opacity": 1
          }
        }
      },
      "media": "",
      "property": "animationName",
      "selectors": [["@keyframes", " ", "m7cxh"]],
      "value": "m7cxh"
    },
    {
      "block": [
        {
          "animation-name": "m7cxh"
        }
      ],
      "emit": true,
      "identifier": "m7cxh",
      "input": {
        "animationName": {
          "0%": {
            "opacity": 0
          },
          "100%": {
            "opacity": 1
          }
        }
      },
      "media": "(min-width: 768px)",
      "property": "animationName",
      "selectors": [[".m7cxh"]],
      "value": "m7cxh"
    }
  ]

  t.deepEqual (actual, expect)
})
/* eslint-disable max-lines-per-function */

ava ("given an object with placeholder and selectors", (t) => {
  const actual = parse ({
    "input": {
      "%figure": true,
      "%figure > ul": {
        "listStyleType": "none"
      },
      ":hover": {
        "[class^=product]&": {
          "backgroundColor": "#0f0"
        },
        "color": "#f00"
      },
      "color": "#f00"
    }
  })

  const expect = [
    {
      "block": [{ "%figure": true }],
      "emit": true,
      "identifier": "af3qz",
      "input": { "%figure": true },
      "media": "",
      "property": "%figure",
      "selectors": [],
      "value": true
    },
    {
      "block": [{ "list-style-type": "none" }],
      "emit": false,
      "identifier": "eor94",
      "input": { "listStyleType": "none" },
      "media": "",
      "property": "listStyleType",
      "selectors": [[".af3qz", ">", "ul"]],
      "value": "none"
    },
    {
      "block": [{ "background-color": "#0f0" }],
      "emit": false,
      "identifier": "jtowj",
      "input": { "backgroundColor": "#0f0" },
      "media": "",
      "property": "backgroundColor",
      "selectors": [["[class^=product]", ":hover"]],
      "value": "#0f0"
    },
    {
      "block": [{ "color": "#f00" }],
      "emit": true,
      "identifier": "jkdzh",
      "input": { "color": "#f00" },
      "media": "",
      "property": "color",
      "selectors": [[".jkdzh", ":hover"]],
      "value": "#f00"
    },
    {
      "block": [{ "color": "#f00" }],
      "emit": true,
      "identifier": "jk2a9",
      "input": { "color": "#f00" },
      "media": "",
      "property": "color",
      "selectors": [[".jk2a9"]],
      "value": "#f00"
    }
  ]

  t.deepEqual (actual, expect)
})

ava ("given an object with bare element selector", (t) => {
  const actual = parse ({
    "input": {
      "body": {
        "margin": 0
      },
      "margin": 0
    }
  })

  const expect = [
    {
      "block": [{ "margin": 0 }],
      "emit": false,
      "identifier": "e4838",
      "input": { "margin": 0 },
      "media": "",
      "property": "margin",
      "selectors": [["body"]],
      "value": 0
    },
    {
      "block": [{ "margin": 0 }],
      "emit": true,
      "identifier": "e482s",
      "input": { "margin": 0 },
      "media": "",
      "property": "margin",
      "selectors": [[".e482s"]],
      "value": 0
    }
  ]

  t.deepEqual (actual, expect)
})

ava ("given an object with 'margin' property and integer value (1)", (t) => {
  const actual = parse ({
    "input": {
      "margin": 10
    }
  })

  const expect = [
    {
      "block": [{ "margin": "10px" }],
      "emit": true,
      "identifier": "e434t",
      "input": { "margin": 10 },
      "media": "",
      "property": "margin",
      "selectors": [[".e434t"]],
      "value": "10px"
    }
  ]

  t.deepEqual (actual, expect)
})
#+end_src
#+HTML: </details>

*** Store

**** cache

#+HTML: <details>
#+begin_src js :tangle src/store/cache.js
import { merge, store } from "../api/index.js"

export function cache (params = {}) {
  const block = params.block || []
  const media = params.media || ""

  const key = JSON.stringify (block)

  if (!store.has (media)) {
    store.set (media, new Map ())
  }

  if (store.get (media).has (key)) {
    const style = store.get (media).get (key)

    const addSelector =
      style.selectors.findIndex (function (selector) {
        return selector.join ("") === params.selectors[0].join ("")
      }) < 0

    store.get (media).set (
      key,
      merge (
        params,
        {
          "selectors": null
        },
        {
          "selectors": (addSelector
            ? style.selectors.concat (params.selectors)
            : style.selectors
          ).sort (function (a, b) {
            return a.length - b.length || a.join ("").localeCompare (b.join (""))
          })
        }
      )
    )
  } else {
    store.get (media).set (key, params)
  }

  return store.get (media).get (key)
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/store/cache.test.js
import ava from "ava"
import { cache } from "./cache.js"
import { store } from "./store.js"

ava.serial ("given undefined arguments", (t) => {
  const actual = cache ()

  const expect1 = {}
  const expect2 = store.has ("")
  const expect3 = store.get ("")

  t.deepEqual (actual, expect1)
  t.true (expect2)
  t.true (expect3 instanceof Map)
})

ava.serial ("given an object with valid property and value (1)", (t) => {
  const actual = cache ({
    "block": [
      {
        "background-color": "#f00"
      }
    ],
    "emit": true,
    "identifier": "jt2a9",
    "input": {
      "background-color": "#f00"
    },
    "media": "",
    "property": "backgroundColor",
    "selectors": [[".jt2a9"]],
    "value": "#f00"
  })

  const expect = {
    "block": [
      {
        "background-color": "#f00"
      }
    ],
    "emit": true,
    "identifier": "jt2a9",
    "input": {
      "background-color": "#f00"
    },
    "media": "",
    "property": "backgroundColor",
    "selectors": [[".jt2a9"]],
    "value": "#f00"
  }

  t.deepEqual (actual, expect)
})

ava.serial ("given an object with valid property and value (2)", (t) => {
  const actual = cache ({
    "block": [
      {
        "background-color": "#f00"
      }
    ],
    "emit": true,
    "identifier": "jtdzh",
    "input": {
      "background-color": "#f00"
    },
    "media": "",
    "property": "backgroundColor",
    "selectors": [[".jtdzh", ":hover"]],
    "value": "#f00"
  })

  const expect = {
    "block": [
      {
        "background-color": "#f00"
      }
    ],
    "emit": true,
    "identifier": "jtdzh",
    "input": {
      "background-color": "#f00"
    },
    "media": "",
    "property": "backgroundColor",
    "selectors": [[".jt2a9"], [".jtdzh", ":hover"]],
    "value": "#f00"
  }

  t.deepEqual (actual, expect)
})

ava.serial ("given an object with valid property and value (3)", (t) => {
  const actual = cache ({
    "block": [
      {
        "background-color": "#f00"
      }
    ],
    "emit": true,
    "identifier": "jtdzh",
    "input": {
      "background-color": "#f00"
    },
    "media": "",
    "property": "backgroundColor",
    "selectors": [[".jtdzh", ":hover"]],
    "value": "#f00"
  })

  const expect = {
    "block": [
      {
        "background-color": "#f00"
      }
    ],
    "emit": true,
    "identifier": "jtdzh",
    "input": {
      "background-color": "#f00"
    },
    "media": "",
    "property": "backgroundColor",
    "selectors": [[".jt2a9"], [".jtdzh", ":hover"]],
    "value": "#f00"
  }

  t.deepEqual (actual, expect)
})
#+end_src
#+HTML: </details>

**** store

#+HTML: <details>
#+begin_src js :tangle src/store/store.js
export const store = (function (STORE) {
  return STORE
}) (new Map ())
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/store/store.test.js
import ava from "ava"
import { store } from "./store.js"

ava.serial ("when 'store' module' is imported", (t) => {
  const actual = store instanceof Map

  t.true (actual)
})

ava.serial ("given 'true' is set for the 'one' key", (t) => {
  store.set ("one", true)

  const actual = store.get ("one")

  t.true (actual)
})

ava.serial ("given 'false' is set for the 'two' key", (t) => {
  store.set ("two", false)

  const actual = store.get ("two")

  t.false (actual)
})

ava.serial ("given 'true' is get for the 'one' key", (t) => {
  const actual = store.get ("one")

  t.true (actual)
})
#+end_src
#+HTML: </details>

*** Utils

**** camelCase

#+HTML: <details>
#+begin_src js :tangle src/utils/camel-case.js
/**
 * Converts `string` to camel case.
 *
 * @param {string} string
 * - The string to convert.
 *
 * @returns {string}
 *   The camel cased string.
 */

export function camelCase (string = "") {
  return string.replace (/\x2D([a-z])/gu, function (_, a) {
    return a.toUpperCase ()
  })
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/utils/camel-case.test.js
import ava from "ava"
import { camelCase } from "./camel-case.js"

ava ("given undefined arguments", (t) => {
  const actual = camelCase ()
  const expect = ""

  t.is (actual, expect)
})

ava ("given a string in kebab-case", (t) => {
  const actual = camelCase ("background-color")
  const expect = "backgroundColor"

  t.is (actual, expect)
})

ava ("given a string in camel-case", (t) => {
  const actual = camelCase ("backgroundColor")
  const expect = "backgroundColor"

  t.is (actual, expect)
})

ava ("given a string in lowercase", (t) => {
  const actual = camelCase ("background")
  const expect = "background"

  t.is (actual, expect)
})
#+end_src
#+HTML: </details>

**** debounce

#+HTML: <details>
#+begin_src js
/*! @copyright JS Foundation | @license MIT | @link lodash.com | @version 4.17.11 *//* eslint-disable */function t(t){var n=typeof t;return null!=t&&("object"==n||"function"==n)}var n="object"==typeof global&&global&&global.Object===Object&&global,e="object"==typeof self&&self&&self.Object===Object&&self,r=n||e||Function("return this")(),o=function(){return r.Date.now()},i=r.Symbol,u=Object.prototype,a=u.hasOwnProperty,f=u.toString,c=i?i.toStringTag:void 0;var l=Object.prototype.toString;var v="[object Null]",b="[object Undefined]",p=i?i.toStringTag:void 0;function s(t){return null==t?void 0===t?b:v:p&&p in Object(t)?function(t){var n=a.call(t,c),e=t[c];try{t[c]=void 0;var r=!0}catch(t){}var o=f.call(t);return r&&(n?t[c]=e:delete t[c]),o}(t):function(t){return l.call(t)}(t)}var d="[object Symbol]";var y=NaN,g=/^\s+|\s+$/g,j=/^[-+]0x[0-9a-f]+$/i,m=/^0b[01]+$/i,O=/^0o[0-7]+$/i,h=parseInt;function T(n){if("number"==typeof n)return n;if(function(t){return"symbol"==typeof t||function(t){return null!=t&&"object"==typeof t}(t)&&s(t)==d}(n))return y;if(t(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=t(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(g,"");var r=m.test(n);return r||O.test(n)?h(n.slice(2),r?2:8):j.test(n)?y:+n}var x="Expected a function",S=Math.max,w=Math.min;export function debounce(n,e,r){var i,u,a,f,c,l,v=0,b=!1,p=!1,s=!0;if("function"!=typeof n)throw new TypeError(x);function d(t){var e=i,r=u;return i=u=void 0,v=t,f=n.apply(r,e)}function y(t){var n=t-l;return void 0===l||n>=e||n<0||p&&t-v>=a}function g(){var t=o();if(y(t))return j(t);c=setTimeout(g,function(t){var n=e-(t-l);return p?w(n,a-(t-v)):n}(t))}function j(t){return c=void 0,s&&i?d(t):(i=u=void 0,f)}function m(){var t=o(),n=y(t);if(i=arguments,u=this,l=t,n){if(void 0===c)return function(t){return v=t,c=setTimeout(g,e),b?d(t):f}(l);if(p)return c=setTimeout(g,e),d(l)}return void 0===c&&(c=setTimeout(g,e)),f}return e=T(e)||0,t(r)&&(b=!!r.leading,a=(p="maxWait"in r)?S(T(r.maxWait)||0,e):a,s="trailing"in r?!!r.trailing:s),m.cancel=function(){void 0!==c&&clearTimeout(c),v=0,i=l=u=c=void 0},m.flush=function(){return void 0===c?f:j(o())},m}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/utils/debounce.js
export function debounce (func, wait = 0) {
  let timeout

  return function () {
    clearTimeout (timeout)
    timeout = setTimeout (func, wait)
  }
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/utils/debounce.test.js
/* eslint-disable no-plusplus, no-undefined */

import ava from "ava"
import { debounce } from "./debounce.js"

ava ("should debounce a function", (t) => {
  let callCount = 0

  function simpleFn (value) {
    ++callCount
    return value
  }

  simpleFn ()

  const debounced = debounce (simpleFn, 32)

  let results = [debounced ("a"), debounced ("b"), debounced ("c")]

  t.deepEqual (results, [undefined, undefined, undefined])
  t.is (callCount, 1)

  setTimeout (function () {
    t.is (callCount, 2)

    results = [debounced ("d"), debounced ("e"), debounced ("f")]

    t.deepEqual (results, ["c", "c", "c"])
    t.is (callCount, 2)
  }, 128)

  setTimeout (function () {
    t.is (callCount, 3)
  }, 256)
})
#+end_src
#+HTML: </details>

**** kebabCase

#+HTML: <details>
#+begin_src js :tangle src/utils/kebab-case.js
/**
 * Converts `string` to kebab case.
 *
 * @param {string} string
 * - The string to convert.
 *
 * @returns {string}
 *   The kebab cased string.
 */

export function kebabCase (string = "") {
  return string.replace (/[A-Z]|^ms/gu, "-$&").toLowerCase ()
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/utils/kebab-case.test.js
import ava from "ava"
import { kebabCase } from "./kebab-case.js"

ava ("given undefined arguments", (t) => {
  const actual = kebabCase ()
  const expect = ""

  t.is (actual, expect)
})

ava ("given a string in camel-case", (t) => {
  const actual = kebabCase ("backgroundColor")
  const expect = "background-color"

  t.is (actual, expect)
})

ava ("given a string beginning with 'ms-'", (t) => {
  const actual = kebabCase ("msAccelerator")
  const expect = "-ms-accelerator"

  t.is (actual, expect)
})

ava ("given a string already in kebab-case", (t) => {
  const actual = kebabCase ("background-color")
  const expect = "background-color"

  t.is (actual, expect)
})

ava ("given a string with lowercase characters", (t) => {
  const actual = kebabCase ("background")
  const expect = "background"

  t.is (actual, expect)
})
#+end_src
#+HTML: </details>

**** merge

#+HTML: <details>
#+begin_src js :tangle src/utils/merge.js
/* eslint-disable no-use-before-define */

export const isArr = Array.isArray

export function isDef (value) {
  return typeof value !== "undefined"
}

export function isNum (value) {
  return typeof value === "number"
}

export function isObj (value) {
  return typeof value === "object"
}

export function canMerge (value) {
  return (
    Boolean (value) &&
    isObj (value) &&
    !(/^\[object (?:Date|RegExp)\]$/u).test (
      Object.prototype.toString.call (value)
    )
  )
}

export function emptyObj (value) {
  return isArr (value) ? [] : {}
}

export function cloneObj (value) {
  return canMerge (value) ? merge (emptyObj (value), value) : value
}

export function mergeArr (target, source) {
  return (isArr (target) && isArr (source)
    ? target.concat (source)
    : source
  ).map (cloneObj)
}

export function mergeObj (target, source) {
  for (const key of Object.keys (source)) {
    target[key] = merge (
      Object.prototype.hasOwnProperty.call (target, key) ? target[key] : {},
      source[key]
    )
  }

  return target
}

/**
 * This method recursively merges own enumerable string keyed properties of
 * source objects into a new empty object. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * @param  {...Object} sources
 * - The source objects.
 *
 * @returns {Object}
 *   Returns `object`.
 */

export function merge (... sources) {
  return sources.reduce (function (target, source) {
    if (isArr (source)) {
      return mergeArr (target, source)
    } else if (canMerge (source)) {
      return mergeObj (target, source)
    }

    return cloneObj (source)
  }, {})
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/utils/merge.test.js
import ava from "ava"
import { emptyObj, isDef, merge } from "./merge.js"

ava ("given undefined arguments", (t) => {
  const actual = merge ()
  const expect = {}

  t.deepEqual (actual, expect)
})

ava ("given an array as value", (t) => {
  const actual = emptyObj (["a"])
  const expect = []

  t.deepEqual (actual, expect)
})

ava ("given an object as value", (t) => {
  const actual = emptyObj ({ "a": null })
  const expect = {}

  t.deepEqual (actual, expect)
})

ava ("given a defined object", (t) => {
  const actual = isDef ("")
  const expect = true

  t.deepEqual (actual, expect)
})

ava ("given an undefined object", (t) => {
  const actual = isDef ()
  const expect = false

  t.deepEqual (actual, expect)
})

ava ("given two objects", (t) => {
  const actual = merge ({ "a": null }, { "b": null })
  const expect = { "a": null, "b": null }

  t.deepEqual (actual, expect)
})

ava ("given two arrays", (t) => {
  const actual = merge (["a"], ["b"])
  const expect = ["a", "b"]

  t.deepEqual (actual, expect)
})

ava ("merge existing simple keys in target at the roots", (t) => {
  const actual = merge (
    { "key1": "value1", "key3": "value3" },
    { "key1": "changed", "key2": "value2" }
  )

  const expect = {
    "key1": "changed",
    "key2": "value2",
    "key3": "value3"
  }

  t.deepEqual (actual, expect)
})

ava ("should work on array of objects", (t) => {
  const actual = merge (
    [{ "key1": ["one", "two"] }, { "key3": ["four"] }],
    [{ "key1": ["one", "three"], "key2": ["one"] }, { "key3": ["five"] }]
  )

  const expect = [
    { "key1": ["one", "two"] },
    { "key3": ["four"] },
    { "key1": ["one", "three"], "key2": ["one"] },
    { "key3": ["five"] }
  ]

  t.deepEqual (actual, expect)
})
#+end_src
#+HTML: </details>

**** pubSub

#+HTML: <details>
#+begin_src js :tangle src/utils/pub-sub.js
export const pubSub = (function (subs) {
  return {
    "pub": function (b) {
      return subs.map (function (c) {
        return c (b)
      })
    },
    "sub": function (b) {
      const c = subs.push (b) - 1

      return function () {
        return delete subs[c]
      }
    }
  }
}) ([])
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/utils/pub-sub.test.js
/* eslint-disable func-style, no-undefined */

import ava from "ava"
import sinon from "sinon"
import { pubSub } from "./pub-sub.js"

ava.serial ("given a pub without any subs", (t) => {
  const actual = pubSub.pub ()
  const expect = []

  t.deepEqual (actual, expect)
})

ava.serial ("given one sub", (t) => {
  const a = () => "one"

  pubSub.sub (a)

  const actual = pubSub.pub ()
  const expect = ["one"]

  t.deepEqual (actual, expect)
})

ava.serial ("given two subs", (t) => {
  const b = () => "two"
  const c = pubSub.sub (b)

  const actual = pubSub.pub ()
  const expect = ["one", "two"]

  c ()

  t.deepEqual (actual, expect)
})

ava.serial ("given one less sub", (t) => {
  const actual = pubSub.pub ()
  const expect = ["one", undefined]

  t.deepEqual (actual, expect)
})

ava.serial ("given one more sub", (t) => {
  const c = () => "three"

  pubSub.sub (c)

  const actual = pubSub.pub ()
  const expect = ["one", undefined, "three"]

  t.deepEqual (actual, expect)
})

ava.serial ("given a listener with args", (t) => {
  const d = (data) => data

  pubSub.sub (d)

  const actual = pubSub.pub ("input!")
  const expect = ["one", undefined, "three", "input!"]

  t.deepEqual (actual, expect)
})

ava.serial ("given pub and filtering the results", (t) => {
  const actual = pubSub.pub ("stuff!").filter (Boolean)
  const expect = ["one", "three", "stuff!"]

  t.deepEqual (actual, expect)
})

ava.serial ("given two subs and deleting the first", (t) => {
  const e = () => "four"
  const f = () => "five"

  const g = pubSub.sub (e)

  pubSub.sub (f)

  const actual = pubSub.pub ()
  const expect = ["one", undefined, "three", undefined, "four", "five"]

  g ()

  t.deepEqual (actual, expect)
})

ava.serial ("given one sub deleted in prev test", (t) => {
  const actual = pubSub.pub ("ACE")
  const expect = ["one", undefined, "three", "ACE", undefined, "five"]

  t.deepEqual (actual, expect)
})

ava.serial ("spy on a sub function", (t) => {
  const spy = sinon.spy ((data) => `${data} and stuff`)

  pubSub.sub (spy)

  pubSub.pub ("things")
  pubSub.pub ("thing!")

  t.true (spy.calledTwice)
})
#+end_src
#+HTML: </details>

**** toPairs

#+HTML: <details>
#+begin_src js :tangle src/utils/to-pairs.js
export function toPairs (params = {}) {
  return Object.keys (params).map (function (key) {
    return [key, params[key]]
  })
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/utils/to-pairs.test.js
import ava from "ava"
import { toPairs } from "./to-pairs.js"

ava ("given undefined arguments", (t) => {
  const actual = toPairs ()
  const expect = []

  t.deepEqual (actual, expect)
})

ava ("given an object with property string and null value", (t) => {
  const actual = toPairs ({ "color": null })
  const expect = [["color", null]]

  t.deepEqual (actual, expect)
})

ava ("given an object with property string and boolean value", (t) => {
  const actual = toPairs ({ "color": true })
  const expect = [["color", true]]

  t.deepEqual (actual, expect)
})

ava ("given an object with property string and number value", (t) => {
  const actual = toPairs ({ "margin": 0 })
  const expect = [["margin", 0]]

  t.deepEqual (actual, expect)
})

ava ("given an object with property string and string value", (t) => {
  const actual = toPairs ({ "color": "red" })
  const expect = [["color", "red"]]

  t.deepEqual (actual, expect)
})

ava ("given an object with property string and array value", (t) => {
  const actual = toPairs ({ "color": [0, 1] })
  const expect = [["color", [0, 1]]]

  t.deepEqual (actual, expect)
})

ava ("given an object with property string and object value", (t) => {
  const actual = toPairs ({ "color": { "a": 1 } })
  const expect = [["color", { "a": 1 }]]

  t.deepEqual (actual, expect)
})
#+end_src
#+HTML: </details>
