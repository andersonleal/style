* @amory/style
:properties:
:header-args: :cache yes :comments no :mkdirp yes :padline yes :results silent
:end:
#+startup: showall nohideblocks hidestars indent

** Table of Contents                                                   :TOC:
- [[#amorystyle][@amory/style]]
  - [[#license][License]]
  - [[#source][Source]]
    - [[#api][API]]
      - [[#css][css]]
      - [[#index][index]]
    - [[#build][Build]]
      - [[#getblockstring][getBlockString]]
      - [[#getclassname][getClassName]]
      - [[#getpropertyid][getPropertyId]]
      - [[#getselectorsstring][getSelectorsString]]
      - [[#getstringhash][getStringHash]]
      - [[#getstyles][getStyles]]
    - [[#client][Client]]
      - [[#canusedom][canUseDom]]
      - [[#getstyleelement][getStyleElement]]
      - [[#update][update]]
    - [[#parse][Parse]]
      - [[#parseidentifier][parseIdentifier]]
      - [[#parseinput][parseInput]]
      - [[#parsemedia][parseMedia]]
      - [[#parse-1][parse]]
    - [[#store][Store]]
      - [[#cache][cache]]
      - [[#store-1][store]]
    - [[#utils][Utils]]
      - [[#camelcase][camelCase]]
      - [[#kebabcase][kebabCase]]
      - [[#merge][merge]]
      - [[#topairs][toPairs]]

** License

#+begin_quote
Copyright 2019 [[https://github.com/ptb][Peter T Bosse II]]

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
#+end_quote

** Source

*** API

**** css

#+HTML: <details>
#+begin_src js :tangle src/api/css.js
import { getClassName } from "../build/get-class-name.js"
import { update } from "../client/update.js"
import { parse } from "../parse/parse.js"
import { cache } from "../store/cache.js"

export function css (params = {}) {
  return parse ({ "input": params })
    .map (cache)
    .map (update)
    .map (getClassName)
    .filter (Boolean)
    .join (" ")
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/api/css.test.js
import ava from "ava"
import { store } from "../store/store.js"
import { css } from "./css.js"

function strMapToObj (strMap) {
  const obj = Object.create (null)

  for (const [k, v] of strMap) {
    obj[k] = v
  }

  return obj
}

ava ("given undefined arguments", (t) => {
  const actual = css ()
  const expect = ""

  t.deepEqual (actual, expect)
})

ava ("given an object with simple declarations", (t) => {
  const actual1 = css ({
    "backgroundColor": "#f00",
    "display": "block"
  })

  const expect1 = "jt2a9 drtx9"

  const actual2 = strMapToObj (store.get (""))

  const expect2 = {
    '[{"background-color":"#f00"}]': {
      "block": [
        {
          "background-color": "#f00"
        }
      ],
      "emit": true,
      "identifier": "jt2a9",
      "input": {
        "backgroundColor": "#f00"
      },
      "media": "",
      "property": "backgroundColor",
      "selectors": [[".jt2a9"]],
      "value": "#f00"
    },
    '[{"display":"block"}]': {
      "block": [
        {
          "display": "block"
        }
      ],
      "emit": true,
      "identifier": "drtx9",
      "input": {
        "display": "block"
      },
      "media": "",
      "property": "display",
      "selectors": [[".drtx9"]],
      "value": "block"
    }
  }

  t.is (actual1, expect1)
  t.deepEqual (actual2, expect2)
})
#+end_src
#+HTML: </details>

**** index

#+HTML: <details>
#+begin_src js :tangle src/api/index.js
export { css } from "./css.js"
export { getBlockString } from "../build/get-block-string.js"
export { getClassName } from "../build/get-class-name.js"
export { getPropertyId } from "../build/get-property-id.js"
export { getSelectorsString } from "../build/get-selectors-string.js"
export { getStringHash } from "../build/get-string-hash.js"
export { getStyles } from "../build/get-styles.js"
export { canUseDom } from "../client/can-use-dom.js"
export { getStyleElement } from "../client/get-style-element.js"
export { update } from "../client/update.js"
export { parse } from "../parse/parse.js"
export { parseIdentifier } from "../parse/parse-identifier.js"
export { parseInput } from "../parse/parse-input.js"
export { parseMedia } from "../parse/parse-media.js"
export { cache } from "../store/cache.js"
export { store } from "../store/store.js"
export { camelCase } from "../utils/camel-case.js"
export { kebabCase } from "../utils/kebab-case.js"
export {
  canMerge,
  cloneObj,
  emptyObj,
  isArr,
  isObj,
  merge,
  mergeArr,
  mergeObj
} from "../utils/merge.js"
export { toPairs } from "../utils/to-pairs.js"
#+end_src
#+HTML: </details>

*** Build

**** getBlockString

#+HTML: <details>
#+begin_src js :tangle src/build/get-block-string.js
import { toPairs } from "../utils/to-pairs.js"

export function getBlockString (params = {}, compact = true) {
  const block = params.block || []

  return block
    .map (function (rule) {
      return toPairs (rule).map (function (style) {
        const property = style[0]
        const value = style[1]

        return "".concat (property, compact ? ":" : ": ", value)
      })
    })
    .join (compact ? ";" : "; ")
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/build/get-block-string.test.js
import ava from "ava"
import { getBlockString } from "./get-block-string.js"

ava ("given undefined arguments", (t) => {
  const actual = getBlockString ()

  const expect = ""

  t.is (actual, expect)
})

ava ("given a block with simple property and value", (t) => {
  const actual = getBlockString ({
    "block": [
      {
        "background-color": "#f00"
      }
    ]
  })

  const expect = "background-color:#f00"

  t.is (actual, expect)
})

ava ("given a block with simple property and value (compact false)", (t) => {
  const actual = getBlockString (
    {
      "block": [
        {
          "background-color": "#f00"
        }
      ]
    },
    false
  )

  const expect = "background-color: #f00"

  t.is (actual, expect)
})

ava ("given a block with fallback properties and value", (t) => {
  const actual = getBlockString ({
    "block": [
      {
        "background-color": "#f00"
      },
      {
        "background-color": "rgba(255, 0, 0, 0.9)"
      }
    ]
  })

  const expect = "background-color:#f00;background-color:rgba(255, 0, 0, 0.9)"

  t.is (actual, expect)
})

ava (
  "given a block with fallback properties and value (compact false)",
  (t) => {
    const actual = getBlockString (
      {
        "block": [
          {
            "background-color": "#f00"
          },
          {
            "background-color": "rgba(255, 0, 0, 0.9)"
          }
        ]
      },
      false
    )

    const expect =
      "background-color: #f00; background-color: rgba(255, 0, 0, 0.9)"

    t.is (actual, expect)
  }
)
#+end_src
#+HTML: </details>

**** getClassName

#+HTML: <details>
#+begin_src js :tangle src/build/get-class-name.js
export function getClassName (params = {}) {
  const emit = params.emit
  const identifier = params.identifier

  return emit ? identifier : null
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/build/get-class-name.test.js
import ava from "ava"
import { getClassName } from "./get-class-name.js"

ava ("given undefined arguments", (t) => {
  const actual = getClassName ()

  const expect = null

  t.deepEqual (actual, expect)
})

ava ("given an object with identifier and emit true", (t) => {
  const actual = getClassName ({
    "emit": true,
    "identifier": "jtz4h",
    "property": "backgroundColor",
    "selectors": [[".jtz4h"]],
    "value": "#0f0"
  })

  const expect = "jtz4h"

  t.deepEqual (actual, expect)
})

ava ("given an object with identifier and emit false", (t) => {
  const actual = getClassName ({
    "block": [
      {
        "src":
          "url('/fonts/font.woff2') format ('woff2'), url('/fonts/font.woff') format ('woff')"
      },
      {
        "font-family": "c5xq1"
      }
    ],
    "emit": false,
    "identifier": "c5xq1",
    "input": {
      "fontFamily": {
        "src":
          "url('/fonts/font.woff2') format ('woff2'), url('/fonts/font.woff') format ('woff')"
      }
    },
    "media": "",
    "property": "fontFamily",
    "selectors": [["@font-face"]],
    "value": {
      "src":
        "url('/fonts/font.woff2') format ('woff2'), url('/fonts/font.woff') format ('woff')"
    }
  })

  const expect = null

  t.deepEqual (actual, expect)
})
#+end_src
#+HTML: </details>

**** getPropertyId

#+HTML: <details>
#+begin_src js :tangle src/build/get-property-id.js
import { camelCase } from "../utils/camel-case.js"

/**
 * @param {string} propertyName
 * - Property name/identifier specifying a stylistic CSS feature to change.
 *
 * @returns {number}
 */

export function getPropertyId (propertyName = "") {
  const n = parseInt ("af", 36)

  switch (true) {
    case (/^%/u).test (propertyName):
      return 0 + n
    case (/^\x2D\x2D/u).test (propertyName):
      return 1 + n
    default:
      return (
        "$*,--*,all,direction,unicodeBidi,writingMode,textOrientation,glyphOrientationVertical,textCombineUpright,textTransform,whiteSpace,textSpaceCollapse,textSpaceTrim,tabSize,wordBreak,lineBreak,hyphens,overflowWrap,wordWrap,textWrap,wrapBefore,wrapAfter,wrapInside,hyphenateCharacter,hyphenateLimitZone,hyphenateLimitChars,hyphenateLimitLines,hyphenateLimitLast,textAlign,textAlignAll,textAlignLast,textJustify,textGroupAlign,wordSpacing,letterSpacing,linePadding,textSpacing,textIndent,hangingPunctuation,textDecoration,textDecorationLine,textDecorationStyle,textDecorationColor,textDecorationWidth,textDecorationSkip,textDecorationSkipInk,textUnderlineOffset,textUnderlinePosition,textEmphasis,textEmphasisStyle,textEmphasisColor,textEmphasisPosition,textEmphasisSkip,textShadow,src,font,fontStyle,fontVariant,fontWeight,fontStretch,fontSize,lineHeight,fontFamily,fontMinSize,fontMaxSize,fontSizeAdjust,fontSynthesis,fontSynthesisWeight,fontSynthesisStyle,fontSynthesisSmallCaps,unicodeRange,fontFeatureSettings,fontVariationSettings,fontLanguageOverride,fontKerning,fontVariantLigatures,fontVariantPosition,fontVariantCaps,fontVariantNumeric,fontVariantAlternates,fontVariantEastAsian,fontOpticalSizing,fontPalette,fontVariantEmoji,content,quotes,stringSet,bookmarkLevel,bookmarkLabel,bookmarkState,running,footnoteDisplay,footnotePolicy,outline,outlineColor,outlineStyle,outlineWidth,outlineOffset,resize,textOverflow,cursor,caret,caretColor,caretShape,navUp,navRight,navDown,navLeft,userSelect,appearance,position,top,right,bottom,left,offsetBefore,offsetAfter,offsetStart,offsetEnd,zIndex,display,contain,width,height,minWidth,minHeight,maxWidth,maxHeight,boxSizing,visibility,pageBreakBefore,pageBreakAfter,pageBreakInside,margin,marginTop,marginRight,marginBottom,marginLeft,marginTrim,padding,paddingTop,paddingRight,paddingBottom,paddingLeft,dominantBaseline,verticalAlign,alignmentBaseline,baselineShift,inlineSizing,initialLetters,initialLettersAlign,initialLettersWrap,listStyle,listStyleType,listStylePosition,listStyleImage,markerSide,counterReset,counterSet,counterIncrement,overflow,overflowX,overflowY,overflowBlock,overflowInline,blockOverflow,lineClamp,maxLines,continue,tableLayout,borderCollapse,borderSpacing,captionSide,emptyCells,flexFlow,flexDirection,flexWrap,order,flex,flexGrow,flexShrink,flexBasis,placeContent,alignContent,justifyContent,placeItems,alignItems,justifyItems,placeSelf,alignSelf,justifySelf,gap,rowGap,columnGap,columns,columnWidth,columnCount,columnRule,columnRuleWidth,columnRuleStyle,columnRuleColor,columnSpan,columnFill,flowInto,flowFrom,regionFragment,breakBefore,breakAfter,breakInside,orphans,widows,boxDecorationBreak,grid,gridTemplate,gridTemplateRows,gridTemplateColumns,gridTemplateAreas,gridAutoFlow,gridAutoRows,gridAutoColumns,gridArea,gridRow,gridRowStart,gridRowEnd,gridColumn,gridColumnStart,gridColumnEnd,rubyPosition,rubyMerge,rubyAlign,float,clear,blockSize,inlineSize,minBlockSize,minInlineSize,maxBlockSize,maxInlineSize,marginBlock,marginBlockStart,marginBlockEnd,marginInline,marginInlineStart,marginInlineEnd,inset,insetBlock,insetBlockStart,insetBlockEnd,insetInline,insetInlineStart,insetInlineEnd,paddingBlock,paddingBlockStart,paddingBlockEnd,paddingInline,paddingInlineStart,paddingInlineEnd,borderBlockWidth,borderBlockStartWidth,borderBlockEndWidth,borderInlineWidth,borderInlineStartWidth,borderInlineEndWidth,borderBlockStyle,borderBlockStartStyle,borderBlockEndStyle,borderInlineStyle,borderInlineStartStyle,borderInlineEndStyle,borderBlockColor,borderBlockStartColor,borderBlockEndColor,borderInlineColor,borderInlineStartColor,borderInlineEndColor,borderBlock,borderBlockStart,borderBlockEnd,borderInline,borderInlineStart,borderInlineEnd,borderStartStartRadius,borderStartEndRadius,borderEndStartRadius,borderEndEndRadius,fillRule,fillBreak,fill,fillColor,fillImage,fillOrigin,fillPosition,fillSize,fillRepeat,fillOpacity,strokeWidth,strokeAlign,strokeLinecap,strokeLinejoin,strokeMiterlimit,strokeBreak,strokeDasharray,strokeDashoffset,strokeDashCorner,strokeDashJustify,stroke,strokeColor,strokeImage,strokeOrigin,strokePosition,strokeSize,strokeRepeat,strokeOpacity,marker,markerStart,markerMid,markerEnd,markerSegment,markerPattern,markerKnockoutLeft,markerKnockoutRight,vectorEffect,colorRendering,shapeRendering,textRendering,imageRendering,bufferedRendering,stopColor,stopOpacity,color,opacity,colorAdjust,objectFit,objectPosition,imageResolution,imageOrientation,imageRendering,background,backgroundColor,backgroundImage,backgroundPosition,backgroundPositionX,backgroundPositionY,backgroundSize,backgroundRepeat,backgroundAttachment,backgroundOrigin,backgroundClip,border,borderTop,borderRight,borderBottom,borderLeft,borderWidth,borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth,borderStyle,borderTopStyle,borderRightStyle,borderBottomStyle,borderLeftStyle,borderColor,borderTopColor,borderRightColor,borderBottomColor,borderLeftColor,borderRadius,borderTopLeftRadius,borderTopRightRadius,borderBottomRightRadius,borderBottomLeftRadius,borderImage,borderImageSource,borderImageSlice,borderImageWidth,borderImageOutset,borderImageRepeat,boxShadow,clip,clipPath,clipRule,mask,maskImage,maskPosition,maskSize,maskRepeat,maskOrigin,maskClip,maskComposite,maskMode,maskBorder,maskBorderSource,maskBorderSlice,maskBorderWidth,maskBorderOutset,maskBorderRepeat,maskBorderMode,maskType,shapeOutside,shapeImageThreshold,shapeMargin,filter,floodColor,floodOpacity,colorInterpolationFilters,lightingColor,mixBlendMode,isolation,backgroundBlendMode,transition,transitionProperty,transitionDuration,transitionTimingFunction,transitionDelay,transform,transformOrigin,transformBox,transformStyle,perspective,perspectiveOrigin,backfaceVisibility,animation,animationName,animationDuration,animationTimingFunction,animationDelay,animationIterationCount,animationDirection,animationFillMode,animationPlayState,offset,offsetPosition,offsetPath,offsetDistance,offsetRotate,offsetAnchor,willChange,scrollSnapType,scrollPadding,scrollPaddingTop,scrollPaddingRight,scrollPaddingBottom,scrollPaddingLeft,scrollPaddingBlock,scrollPaddingBlockStart,scrollPaddingBlockEnd,scrollPaddingInline,scrollPaddingInlineStart,scrollPaddingInlineEnd,scrollMargin,scrollMarginTop,scrollMarginRight,scrollMarginBottom,scrollMarginLeft,scrollMarginBlock,scrollMarginBlockStart,scrollMarginBlockEnd,scrollMarginInline,scrollMarginInlineStart,scrollMarginInlineEnd,scrollSnapAlign,scrollSnapStop,scrollBehavior"
          .split (",")
          .indexOf (camelCase (propertyName)) + n
      )
  }
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src json :tangle src/build/get-property-id.json
{
  "variables": [
    "%*",
    "--*"
  ],

  "cascade": [
    "all"
  ],

  "writingModes": [
    "direction",
    "unicodeBidi",
    "writingMode",
    "textOrientation",
    "glyphOrientationVertical",
    "textCombineUpright"
  ],

  "text": [
    "textTransform",

    "whiteSpace",
    "textSpaceCollapse",
    "textSpaceTrim",
    "tabSize",

    "wordBreak",
    "lineBreak",
    "hyphens",
    "overflowWrap",
    "wordWrap",

    "textWrap",
    "wrapBefore",
    "wrapAfter",
    "wrapInside",

    "hyphenateCharacter",
    "hyphenateLimitZone",
    "hyphenateLimitChars",
    "hyphenateLimitLines",
    "hyphenateLimitLast",

    "textAlign",
    "textAlignAll",
    "textAlignLast",
    "textJustify",
    "textGroupAlign",

    "wordSpacing",
    "letterSpacing",
    "linePadding",
    "textSpacing",

    "textIndent",
    "hangingPunctuation"
  ],

  "textDecor": [
    "textDecoration",
    "textDecorationLine",
    "textDecorationStyle",
    "textDecorationColor",

    "textDecorationWidth",
    "textDecorationSkip",
    "textDecorationSkipInk",

    "textUnderlineOffset",
    "textUnderlinePosition",

    "textEmphasis",
    "textEmphasisStyle",
    "textEmphasisColor",

    "textEmphasisPosition",

    "textEmphasisSkip",

    "textShadow"
  ],

  "fonts": [
    "src",

    "font",
    "fontStyle",
    "fontVariant",
    "fontWeight",
    "fontStretch",
    "fontSize",
    "lineHeight",
    "fontFamily",

    "fontMinSize",
    "fontMaxSize",
    "fontSizeAdjust",

    "fontSynthesis",
    "fontSynthesisWeight",
    "fontSynthesisStyle",
    "fontSynthesisSmallCaps",

    "unicodeRange",

    "fontFeatureSettings",
    "fontVariationSettings",
    "fontLanguageOverride",

    "fontKerning",

    "fontVariantLigatures",
    "fontVariantPosition",
    "fontVariantCaps",
    "fontVariantNumeric",
    "fontVariantAlternates",
    "fontVariantEastAsian",

    "fontOpticalSizing",

    "fontPalette",
    "fontVariantEmoji"
  ],

  "content": [
    "content",
    "quotes",
    "stringSet",
    "bookmarkLevel",
    "bookmarkLabel",
    "bookmarkState"
  ],

  "gcpm": [
    "running",
    "footnoteDisplay",
    "footnotePolicy"
  ],

  "ui": [
    "outline",
    "outlineColor",
    "outlineStyle",
    "outlineWidth",

    "outlineOffset",
    "resize",
    "textOverflow",
    "cursor",

    "caret",
    "caretColor",
    "caretShape",

    "navUp",
    "navRight",
    "navDown",
    "navLeft",

    "userSelect",
    "appearance"
  ],

  "position": [
    "position",

    "top",
    "right",
    "bottom",
    "left",

    "offsetBefore",
    "offsetAfter",
    "offsetStart",
    "offsetEnd",

    "zIndex"
  ],

  "display": [
    "display"
  ],

  "contain": [
    "contain"
  ],

  "sizing": [
    "width",
    "height",

    "minWidth",
    "minHeight",

    "maxWidth",
    "maxHeight",

    "boxSizing"
  ],

  "css2": [
    "visibility",

    "pageBreakBefore",
    "pageBreakAfter",
    "pageBreakInside"
  ],

  "box": [
    "margin",
    "marginTop",
    "marginRight",
    "marginBottom",
    "marginLeft",

    "marginTrim",

    "padding",
    "paddingTop",
    "paddingRight",
    "paddingBottom",
    "paddingLeft"
  ],

  "inline": [
    "dominantBaseline",
    "verticalAlign",
    "alignmentBaseline",
    "baselineShift",

    "inlineSizing",

    "initialLetters",
    "initialLettersAlign",
    "initialLettersWrap"
  ],

  "lists": [
    "listStyle",
    "listStyleType",
    "listStylePosition",
    "listStyleImage",

    "markerSide",

    "counterReset",
    "counterSet",
    "counterIncrement"
  ],

  "overflow": [
    "overflow",
    "overflowX",
    "overflowY",

    "overflowBlock",
    "overflowInline",

    "blockOverflow",
    "lineClamp",
    "maxLines",
    "continue"
  ],

  "tables": [
    "tableLayout",
    "borderCollapse",
    "borderSpacing",
    "captionSide",

    "emptyCells"
  ],

  "flexbox": [
    "flexFlow",
    "flexDirection",
    "flexWrap",

    "order",

    "flex",
    "flexGrow",
    "flexShrink",
    "flexBasis"
  ],

  "align": [
    "placeContent",
    "alignContent",
    "justifyContent",

    "placeItems",
    "alignItems",
    "justifyItems",

    "placeSelf",
    "alignSelf",
    "justifySelf",

    "gap",
    "rowGap",
    "columnGap"
  ],

  "multicol": [
    "columns",
    "columnWidth",
    "columnCount",

    "columnRule",
    "columnRuleWidth",
    "columnRuleStyle",
    "columnRuleColor",

    "columnSpan",
    "columnFill"
  ],

  "regions": [
    "flowInto",
    "flowFrom",
    "regionFragment"
  ],

  "break": [
    "breakBefore",
    "breakAfter",
    "breakInside",
    "orphans",
    "widows",
    "boxDecorationBreak"
  ],

  "grid": [
    "grid",

    "gridTemplate",
    "gridTemplateRows",
    "gridTemplateColumns",
    "gridTemplateAreas",

    "gridAutoFlow",
    "gridAutoRows",
    "gridAutoColumns",

    "gridArea",

    "gridRow",
    "gridRowStart",
    "gridRowEnd",

    "gridColumn",
    "gridColumnStart",
    "gridColumnEnd"
  ],

  "ruby": [
    "rubyPosition",
    "rubyMerge",
    "rubyAlign"
  ],

  "logical": [
    "float",
    "clear",

    "blockSize",
    "inlineSize",
    "minBlockSize",
    "minInlineSize",
    "maxBlockSize",
    "maxInlineSize",

    "marginBlock",
    "marginBlockStart",
    "marginBlockEnd",

    "marginInline",
    "marginInlineStart",
    "marginInlineEnd",

    "inset",
    "insetBlock",
    "insetBlockStart",
    "insetBlockEnd",
    "insetInline",
    "insetInlineStart",
    "insetInlineEnd",

    "paddingBlock",
    "paddingBlockStart",
    "paddingBlockEnd",
    "paddingInline",
    "paddingInlineStart",
    "paddingInlineEnd",

    "borderBlockWidth",
    "borderBlockStartWidth",
    "borderBlockEndWidth",
    "borderInlineWidth",
    "borderInlineStartWidth",
    "borderInlineEndWidth",

    "borderBlockStyle",
    "borderBlockStartStyle",
    "borderBlockEndStyle",
    "borderInlineStyle",
    "borderInlineStartStyle",
    "borderInlineEndStyle",

    "borderBlockColor",
    "borderBlockStartColor",
    "borderBlockEndColor",
    "borderInlineColor",
    "borderInlineStartColor",
    "borderInlineEndColor",

    "borderBlock",
    "borderBlockStart",
    "borderBlockEnd",
    "borderInline",
    "borderInlineStart",
    "borderInlineEnd",

    "borderStartStartRadius",
    "borderStartEndRadius",
    "borderEndStartRadius",
    "borderEndEndRadius"
  ],

  "fillStroke": [
    "fillRule",
    "fillBreak",

    "fill",
    "fillColor",
    "fillImage",
    "fillOrigin",
    "fillPosition",
    "fillSize",
    "fillRepeat",

    "fillOpacity",

    "strokeWidth",
    "strokeAlign",
    "strokeLinecap",
    "strokeLinejoin",
    "strokeMiterlimit",
    "strokeBreak",
    "strokeDasharray",
    "strokeDashoffset",
    "strokeDashCorner",
    "strokeDashJustify",

    "stroke",
    "strokeColor",
    "strokeImage",
    "strokeOrigin",
    "strokePosition",
    "strokeSize",
    "strokeRepeat",

    "strokeOpacity"
  ],

  "svgMarkers": [
    "marker",
    "markerStart",
    "markerMid",
    "markerEnd",

    "markerSegment",
    "markerPattern",

    "markerKnockoutLeft",
    "markerKnockoutRight"
  ],

  "svgTiny": [
    "vectorEffect",

    "colorRendering",
    "shapeRendering",
    "textRendering",
    "imageRendering",
    "bufferedRendering",

    "stopColor",
    "stopOpacity"
  ],

  "color": [
    "color",
    "opacity",

    "colorAdjust"
  ],

  "images": [
    "objectFit",
    "objectPosition",

    "imageResolution",
    "imageOrientation",
    "imageRendering"
  ],

  "backgrounds": [
    "background",
    "backgroundColor",
    "backgroundImage",
    "backgroundPosition",
    "backgroundPositionX",
    "backgroundPositionY",
    "backgroundSize",
    "backgroundRepeat",
    "backgroundAttachment",
    "backgroundOrigin",
    "backgroundClip",

    "border",
    "borderTop",
    "borderRight",
    "borderBottom",
    "borderLeft",

    "borderWidth",
    "borderTopWidth",
    "borderRightWidth",
    "borderBottomWidth",
    "borderLeftWidth",

    "borderStyle",
    "borderTopStyle",
    "borderRightStyle",
    "borderBottomStyle",
    "borderLeftStyle",

    "borderColor",
    "borderTopColor",
    "borderRightColor",
    "borderBottomColor",
    "borderLeftColor",

    "borderRadius",
    "borderTopLeftRadius",
    "borderTopRightRadius",
    "borderBottomRightRadius",
    "borderBottomLeftRadius",

    "borderImage",
    "borderImageSource",
    "borderImageSlice",
    "borderImageWidth",
    "borderImageOutset",
    "borderImageRepeat",

    "boxShadow"
  ],

  "masking": [
    "clip",
    "clipPath",
    "clipRule",

    "mask",
    "maskImage",
    "maskPosition",
    "maskSize",
    "maskRepeat",
    "maskOrigin",
    "maskClip",
    "maskComposite",
    "maskMode",

    "maskBorder",
    "maskBorderSource",
    "maskBorderSlice",
    "maskBorderWidth",
    "maskBorderOutset",
    "maskBorderRepeat",
    "maskBorderMode",

    "maskType"
  ],

  "shapes": [
    "shapeOutside",
    "shapeImageThreshold",
    "shapeMargin"
  ],

  "filterEffects": [
    "filter",
    "floodColor",
    "floodOpacity",
    "colorInterpolationFilters",
    "lightingColor"
  ],

  "compositing": [
    "mixBlendMode",
    "isolation",
    "backgroundBlendMode"
  ],

  "transitions": [
    "transition",
    "transitionProperty",
    "transitionDuration",
    "transitionTimingFunction",
    "transitionDelay"
  ],

  "transforms": [
    "transform",
    "transformOrigin",
    "transformBox",
    "transformStyle",

    "perspective",
    "perspectiveOrigin",
    "backfaceVisibility"
  ],

  "animations": [
    "animation",
    "animationName",
    "animationDuration",
    "animationTimingFunction",
    "animationDelay",
    "animationIterationCount",
    "animationDirection",
    "animationFillMode",
    "animationPlayState"
  ],

  "motion": [
    "offset",
    "offsetPosition",
    "offsetPath",
    "offsetDistance",
    "offsetRotate",
    "offsetAnchor"
  ],

  "willChange": [
    "willChange"
  ],

  "scrollSnap": [
    "scrollSnapType",

    "scrollPadding",
    "scrollPaddingTop",
    "scrollPaddingRight",
    "scrollPaddingBottom",
    "scrollPaddingLeft",

    "scrollPaddingBlock",
    "scrollPaddingBlockStart",
    "scrollPaddingBlockEnd",

    "scrollPaddingInline",
    "scrollPaddingInlineStart",
    "scrollPaddingInlineEnd",

    "scrollMargin",
    "scrollMarginTop",
    "scrollMarginRight",
    "scrollMarginBottom",
    "scrollMarginLeft",

    "scrollMarginBlock",
    "scrollMarginBlockStart",
    "scrollMarginBlockEnd",

    "scrollMarginInline",
    "scrollMarginInlineStart",
    "scrollMarginInlineEnd",

    "scrollSnapAlign",
    "scrollSnapStop"
  ],

  "cssomView": [
    "scrollBehavior"
  ]
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/build/get-property-id.test.js
import ava from "ava"
import { getPropertyId } from "./get-property-id.js"

ava ("given undefined arguments", (t) => {
  const actual = getPropertyId ()
  const expect = 374

  t.is (actual, expect)
})

ava ("given an empty string", (t) => {
  const actual = getPropertyId ("")
  const expect = 374

  t.is (actual, expect)
})

ava ("given a string with an invalid property name", (t) => {
  const actual = getPropertyId ("xyz")
  const expect = 374

  t.is (actual, expect)
})

ava ("given a string with a valid placeholder class name", (t) => {
  const actual = getPropertyId ("%productList")
  const expect = 375

  t.is (actual, expect)
})

ava ("given a string with a valid CSS variable name", (t) => {
  const actual = getPropertyId ("--background-color")
  const expect = 376

  t.is (actual, expect)
})

ava ("given a string with a valid property name (1)", (t) => {
  const actual = getPropertyId ("background")
  const expect = 712

  t.is (actual, expect)
})

ava ("given a string with a valid property name (2)", (t) => {
  const actual = getPropertyId ("background-color")
  const expect = 713

  t.is (actual, expect)
})
#+end_src
#+HTML: </details>

**** getSelectorsString

#+HTML: <details>
#+begin_src js :tangle src/build/get-selectors-string.js
export function getSelectorsString (params = {}, compact = true) {
  const selectors = params.selectors || []

  return selectors
    .map (function (selector) {
      return selector.join ("")
    })
    .join (compact ? "," : ", ")
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/build/get-selectors-string.test.js
import ava from "ava"
import { getSelectorsString } from "./get-selectors-string.js"

ava ("given undefined arguments", (t) => {
  const actual = getSelectorsString ()

  const expect = ""

  t.is (actual, expect)
})

ava ("given an object with empty selectors (1)", (t) => {
  const actual = getSelectorsString ({
    "selectors": []
  })

  const expect = ""

  t.is (actual, expect)
})

ava ("given an object with empty selectors (2)", (t) => {
  const actual = getSelectorsString ({
    "selectors": [[]]
  })

  const expect = ""

  t.is (actual, expect)
})

ava ("given an object with single selector (1)", (t) => {
  const actual = getSelectorsString ({
    "selectors": [[".abcde"]]
  })

  const expect = ".abcde"

  t.is (actual, expect)
})

ava ("given an object with single selector (2)", (t) => {
  const actual = getSelectorsString ({
    "selectors": [[".abcde", ">", ".fghij"]]
  })

  const expect = ".abcde>.fghij"

  t.is (actual, expect)
})

ava ("given an object with multiple selectors (1)", (t) => {
  const actual = getSelectorsString ({
    "selectors": [[".abcde"], [".fghij"]]
  })

  const expect = ".abcde,.fghij"

  t.is (actual, expect)
})

ava ("given an object with multiple selectors (2)", (t) => {
  const actual = getSelectorsString (
    {
      "selectors": [[".abcde"], [".fghij"]]
    },
    false
  )

  const expect = ".abcde, .fghij"

  t.is (actual, expect)
})

ava ("given an object with multiple selectors (3)", (t) => {
  const actual = getSelectorsString ({
    "selectors": [[".abcde", ":hover"], [".fghij"]]
  })

  const expect = ".abcde:hover,.fghij"

  t.is (actual, expect)
})

ava ("given an object with multiple selectors (4)", (t) => {
  const actual = getSelectorsString (
    {
      "selectors": [[".abcde", ":hover"], [".fghij"]]
    },
    false
  )

  const expect = ".abcde:hover, .fghij"

  t.is (actual, expect)
})
#+end_src
#+HTML: </details>

**** getStringHash

#+HTML: <details>
#+begin_src js :tangle src/build/get-string-hash.js
/**
 * Converts `string` to unique hash identifier string.
 *
 * @param {string} string
 * - The string to convert.
 *
 * @returns {string}
 *   The string hash identifier.
 */

export function getStringHash (string = "") {
  return string
    .split ("")
    .reduce (function (i, str) {
      return i << 5 ^ i ^ str.charCodeAt () & 0xffffffffff
    }, 5381 << 2)
    .toString (36)
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/build/get-string-hash.test.js
import ava from "ava"
import { getStringHash } from "./get-string-hash.js"

ava ("given undefined arguments", (t) => {
  const actual = getStringHash ().slice (-3)
  const expect = "glw"

  t.is (actual, expect)
})

ava ("given an empty string", (t) => {
  const actual = getStringHash ("").slice (-3)
  const expect = "glw"

  t.is (actual, expect)
})

ava ("given a simple string (1)", (t) => {
  const actual = getStringHash ("abc").slice (-3)
  const expect = "ed0"

  t.is (actual, expect)
})

ava ("given a simple string (2)", (t) => {
  const actual = getStringHash ("abcd").slice (-3)
  const expect = "47k"

  t.is (actual, expect)
})
#+end_src
#+HTML: </details>

**** getStyles

#+HTML: <details>
#+begin_src js :tangle src/build/get-styles.js
import { store } from "../store/store.js"
import { getBlockString } from "./get-block-string.js"
import { getSelectorsString } from "./get-selectors-string.js"

export function getStyles (media = "", compact = true) {
  const styles = []

  store.get (media).forEach (function (style) {
    styles.push (
      "".concat (
        getSelectorsString (style, compact),
        compact ? "{" : " { ",
        getBlockString (style, compact),
        compact ? "}" : " }"
      )
    )
  })

  return styles.join (compact ? "" : "\n")
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/build/get-styles.test.js
import ava from "ava"
import { cache } from "../store/cache.js"
import { getStyles } from "./get-styles.js"

ava.serial ("given an object with simple property and value", (t) => {
  cache ({
    "block": [
      {
        "background-color": "#f00"
      }
    ],
    "identifier": "jt2a9",
    "property": "backgroundColor",
    "selectors": [[".jt2a9"]],
    "value": "#f00"
  })

  const actual = getStyles ()

  const expect = ".jt2a9{background-color:#f00}"

  t.is (actual, expect)
})

ava.serial (
  "given an object with simple property and value (compact false)",
  (t) => {
    cache ({
      "block": [
        {
          "background-color": "#f00"
        }
      ],
      "identifier": "jt2a9",
      "property": "backgroundColor",
      "selectors": [[".jt2a9"]],
      "value": "#f00"
    })

    const actual = getStyles ("", false)

    const expect = ".jt2a9 { background-color: #f00 }"

    t.is (actual, expect)
  }
)

ava.serial ("given an object with simple property and value (2)", (t) => {
  cache ({
    "block": [
      {
        "background-color": "#f00"
      }
    ],
    "emit": true,
    "identifier": "jtdzh",
    "input": {
      "background-color": "#f00"
    },
    "media": "",
    "property": "backgroundColor",
    "selectors": [[".jtdzh", ":hover"]],
    "value": "#f00"
  })

  const actual = getStyles ()

  const expect = ".jt2a9,.jtdzh:hover{background-color:#f00}"

  t.is (actual, expect)
})

ava.serial (
  "given an object with simple property and value (compact false) (2)",
  (t) => {
    const actual = getStyles ("", false)

    const expect = ".jt2a9, .jtdzh:hover { background-color: #f00 }"

    t.is (actual, expect)
  }
)
#+end_src
#+HTML: </details>

*** Client

**** canUseDom

#+HTML: <details>
#+begin_src js :tangle src/client/can-use-dom.js
/* istanbul ignore next */

/**
 * @returns {boolean}
 */

export const canUseDom = Boolean (
  typeof window !== "undefined" &&
    window.document &&
    window.document.createElement
)
#+end_src
#+HTML: </details>

**** getStyleElement

#+HTML: <details>
#+begin_src js :tangle src/client/get-style-element.js
/* istanbul ignore next */

export function getStyleElement (media = "") {
  const styles = document.getElementsByTagName ("style")

  let style

  for (style of styles) {
    if (style.media === media) {
      return style
    }
  }

  style = document.createElement ("style")

  if (media.length) {
    style.media = media
  }

  document.head.appendChild (style)

  return style
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/client/get-style-element.test.js
/* global browser, page */

import ava from "ava"
import http from "http"
import puppeteer from "puppeteer"
import { getStyleElement } from "./get-style-element.js"

function httpContent (content = "") {
  return `<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><title> </title>${content}</head></html>`
}

ava.before (async () => {
  http
    .createServer ((request, response) => {
      response.setHeader ("Content-type", "application/xhtml+xml")

      switch (request.url) {
        case "/a":
          return response.end (httpContent ())
        case "/b":
          return response.end (httpContent (`<style>.b{all:inherit}</style>`))
        case "/c":
          return response.end (
            httpContent (
              `<style media="(min-width: 768px)">.c{gap:1px}</style>`
            )
          )
      }

      return response.end ()
    })
    .listen (7000)

  global.browser = await puppeteer.launch ()
})

ava.beforeEach (async () => {
  global.page = await browser.newPage ()
})

ava.afterEach.always (async () => {
  await page.close ()
})

ava.after.always (async () => {
  await browser.close ()
})

ava.serial ("given URL '/a', verify returned contents (1)", async (t) => {
  await page.goto ("http://localhost:7000/a", { "waitUntil": "networkidle0" })

  const actual = await page.content ()

  const expect = httpContent ()

  t.is (actual, expect)
})

ava.serial ("given URL '/a', create a new style element (2)", async (t) => {
  await page.goto ("http://localhost:7000/a", { "waitUntil": "networkidle0" })

  const style = await page
    .evaluateHandle (getStyleElement)
    .then ((el) => el._remoteObject.className)

  const actual = await page.content ()

  const expect = httpContent (`<style></style>`)

  t.is (style, "HTMLStyleElement")
  t.is (actual, expect)
})

ava.serial ("given URL '/a', create a new style element (3)", async (t) => {
  await page.goto ("http://localhost:7000/a", { "waitUntil": "networkidle0" })

  const style = await page
    .evaluateHandle (getStyleElement, "(min-width: 768px)")
    .then ((el) => el._remoteObject.className)

  const actual = await page.content ()

  const expect = httpContent (`<style media="(min-width: 768px)"></style>`)

  t.is (style, "HTMLStyleElement")
  t.is (actual, expect)
})

ava.serial ("given URL '/b', verify returned contents (1)", async (t) => {
  await page.goto ("http://localhost:7000/b", { "waitUntil": "networkidle0" })

  const actual = await page.content ()

  const expect = httpContent (`<style>.b{all:inherit}</style>`)

  t.is (actual, expect)
})

ava.serial (
  "given URL '/b', should re-use existing style element (2)",
  async (t) => {
    await page.goto ("http://localhost:7000/b", { "waitUntil": "networkidle0" })

    const style = await page
      .evaluateHandle (getStyleElement)
      .then ((el) => el._remoteObject.className)

    const actual = await page.content ()

    const expect = httpContent (`<style>.b{all:inherit}</style>`)

    t.is (style, "HTMLStyleElement")
    t.is (actual, expect)
  }
)

ava.serial (
  "given URL '/b', should create additional style element (3)",
  async (t) => {
    await page.goto ("http://localhost:7000/b", { "waitUntil": "networkidle0" })

    const style = await page
      .evaluateHandle (getStyleElement, "(min-width: 768px)")
      .then ((el) => el._remoteObject.className)

    const actual = await page.content ()

    const expect = httpContent (
      /* eslint-disable-next-line max-len */
      `<style>.b{all:inherit}</style><style media="(min-width: 768px)"></style>`
    )

    t.is (style, "HTMLStyleElement")
    t.is (actual, expect)
  }
)

ava.serial ("given URL '/c', verify returned contents (1)", async (t) => {
  await page.goto ("http://localhost:7000/c", { "waitUntil": "networkidle0" })

  const actual = await page.content ()

  const expect = httpContent (
    `<style media="(min-width: 768px)">.c{gap:1px}</style>`
  )

  t.is (actual, expect)
})

ava.serial (
  "given URL '/c', should create additional style element (2)",
  async (t) => {
    await page.goto ("http://localhost:7000/c", { "waitUntil": "networkidle0" })

    const style = await page
      .evaluateHandle (getStyleElement)
      .then ((el) => el._remoteObject.className)

    const actual = await page.content ()

    const expect = httpContent (
      `<style media="(min-width: 768px)">.c{gap:1px}</style><style></style>`
    )

    t.is (style, "HTMLStyleElement")
    t.is (actual, expect)
  }
)

ava.serial (
  "given URL '/c', should re-use existing style element (3)",
  async (t) => {
    await page.goto ("http://localhost:7000/c", { "waitUntil": "networkidle0" })

    const style = await page
      .evaluateHandle (getStyleElement, "(min-width: 768px)")
      .then ((el) => el._remoteObject.className)

    const actual = await page.content ()

    const expect = httpContent (
      `<style media="(min-width: 768px)">.c{gap:1px}</style>`
    )

    t.is (style, "HTMLStyleElement")
    t.is (actual, expect)
  }
)
#+end_src
#+HTML: </details>

**** update

#+HTML: <details>
#+begin_src js :tangle src/client/update.js
import { getStyles } from "../build/get-styles.js"
import { store } from "../store/store.js"
import { canUseDom } from "./can-use-dom.js"
import { getStyleElement } from "./get-style-element.js"

/* istanbul ignore next */

export const update = (function (elements) {
  return function (params = {}, compact = true) {
    store.forEach (function (_, media) {
      canUseDom &&
        window.requestAnimationFrame (function () {
          const styles = getStyles (media, compact)

          const style = elements.has (media)
            ? elements.get (media)
            : getStyleElement (media)

          style.innerHTML = styles
          elements.set (media, style)
        })
    })

    return params
  }
}) (new Map ())
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/client/update.test.js
import ava from "ava"
import { store } from "../store/store.js"
import { update } from "./update.js"

ava ("1", (t) => {
  store.set (
    "",
    new Map ([
      [
        '[{"background-color":"#f00"}]',
        {
          "block": [
            {
              "background-color": "#f00"
            }
          ],
          "emit": true,
          "identifier": "jt2a9",
          "input": {
            "background-color": "#f00"
          },
          "media": "",
          "property": "backgroundColor",
          "selectors": [[".jt2a9"]]
        }
      ],
      [
        '[{"display":"flex"},{"display":"grid"}]',
        {
          "block": [{ "display": "flex" }, { "display": "grid" }],
          "emit": true,
          "identifier": "dr7nz",
          "input": {
            "display": ["flex", "grid"]
          },
          "media": "",
          "property": "display",
          "selectors": [[".dr7nz"]]
        }
      ]
    ])
  )

  const actual = update ()

  const expect = {}

  t.deepEqual (actual, expect)
})

ava ("2", (t) => {
  store.set (
    "(min-width: 768px)",
    new Map ([
      [
        '[{"background-color":"#f00"}]',
        {
          "block": [
            {
              "background-color": "#f00"
            }
          ],
          "emit": true,
          "identifier": "jt2a9",
          "input": {
            "background-color": "#f00"
          },
          "media": "",
          "property": "backgroundColor",
          "selectors": [[".jt2a9"]]
        }
      ],
      [
        '[{"display":"flex"},{"display":"grid"}]',
        {
          "block": [{ "display": "flex" }, { "display": "grid" }],
          "emit": true,
          "identifier": "dr7nz",
          "input": {
            "display": ["flex", "grid"]
          },
          "media": "",
          "property": "display",
          "selectors": [[".dr7nz"]]
        }
      ]
    ])
  )

  const actual = update ()

  const expect = {}

  t.deepEqual (actual, expect)
})
#+end_src
#+HTML: </details>

*** Parse

**** parseIdentifier

#+HTML: <details>
#+begin_src js :tangle src/parse/parse-identifier.js
import { getPropertyId } from "../build/get-property-id.js"
import { getStringHash } from "../build/get-string-hash.js"
import { merge } from "../utils/merge.js"

export function parseIdentifier (params = {}) {
  if (params.property) {
    const media = params.media || ""
    const property = params.property
    const value = params.value

    let selectors = params.selectors || []

    const identifier =
      typeof params.identifier === "undefined"
        ? getPropertyId (property).toString (36) +
          getStringHash (
            ""
              .concat (media)
              .concat (
                selectors
                  .map (function (selector) {
                    return selector.join ("")
                  })
                  .join (",")
              )
              .concat (JSON.stringify (value))
          ).slice (-3)
        : params.identifier

    selectors =
      selectors.length || (/^%/u).test (property)
        ? selectors.map (function (selector) {
          return (/^:/u).test (selector[0])
            ? [].concat (".".concat (identifier), selector)
            : selector
        })
        : selectors.concat ([[".".concat (identifier)]])

    return merge (params, { "selectors": null }, { identifier, selectors })
  }

  return params
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/parse/parse-identifier.test.js
import ava from "ava"
import { parseIdentifier } from "./parse-identifier.js"

ava ("given undefined arguments", (t) => {
  const actual = parseIdentifier ()
  const expect = {}

  t.deepEqual (actual, expect)
})

ava ("given an object with undefined identifier (1)", (t) => {
  const actual = parseIdentifier ({
    "property": "backgroundColor",
    "value": "#f00"
  })

  const expect = {
    "identifier": "jt2a9",
    "property": "backgroundColor",
    "selectors": [[".jt2a9"]],
    "value": "#f00"
  }

  t.deepEqual (actual, expect)
})

ava ("given an object with undefined identifier (2)", (t) => {
  const actual = parseIdentifier ({
    "property": "backgroundColor",
    "value": "#0f0"
  })

  const expect = {
    "identifier": "jtz4h",
    "property": "backgroundColor",
    "selectors": [[".jtz4h"]],
    "value": "#0f0"
  }

  t.deepEqual (actual, expect)
})

ava ("given an object with undefined identifier (3)", (t) => {
  const actual = parseIdentifier ({
    "property": "color",
    "value": "#0f0"
  })

  const expect = {
    "identifier": "jkz4h",
    "property": "color",
    "selectors": [[".jkz4h"]],
    "value": "#0f0"
  }

  t.deepEqual (actual, expect)
})

ava ("given an object with undefined identifier and media (1)", (t) => {
  const actual = parseIdentifier ({
    "media": "(max-width: 767px)",
    "property": "color",
    "value": "#0f0"
  })

  const expect = {
    "identifier": "jkmmt",
    "media": "(max-width: 767px)",
    "property": "color",
    "selectors": [[".jkmmt"]],
    "value": "#0f0"
  }

  t.deepEqual (actual, expect)
})

ava ("given an object with undefined identifier and media (2)", (t) => {
  const actual = parseIdentifier ({
    "media": "(min-width: 768px)",
    "property": "color",
    "value": "#0f0"
  })

  const expect = {
    "identifier": "jkduu",
    "media": "(min-width: 768px)",
    "property": "color",
    "selectors": [[".jkduu"]],
    "value": "#0f0"
  }

  t.deepEqual (actual, expect)
})

ava ("given an object with undefined identifier and selectors (1)", (t) => {
  const actual = parseIdentifier ({
    "property": "color",
    "selectors": [[":active"]],
    "value": "#0f0"
  })

  const expect = {
    "identifier": "jkk07",
    "property": "color",
    "selectors": [[".jkk07", ":active"]],
    "value": "#0f0"
  }

  t.deepEqual (actual, expect)
})

ava ("given an object with undefined identifier and selectors (2)", (t) => {
  const actual = parseIdentifier ({
    "property": "color",
    "selectors": [[":hover"]],
    "value": "#0f0"
  })

  const expect = {
    "identifier": "jkgwd",
    "property": "color",
    "selectors": [[".jkgwd", ":hover"]],
    "value": "#0f0"
  }

  t.deepEqual (actual, expect)
})

ava (
  "given an object with undefined identifier, media, and selectors",
  (t) => {
    const actual = parseIdentifier ({
      "media": "(min-width: 768px)",
      "property": "color",
      "selectors": [[":hover"]],
      "value": "#0f0"
    })

    const expect = {
      "identifier": "jkda2",
      "media": "(min-width: 768px)",
      "property": "color",
      "selectors": [[".jkda2", ":hover"]],
      "value": "#0f0"
    }

    t.deepEqual (actual, expect)
  }
)

ava ("given an object with undefined identifier with selectors", (t) => {
  const actual = parseIdentifier ({
    "property": "background-color",
    "selectors": [[".abcde"]],
    "value": "#f00"
  })

  const expect = {
    "identifier": "jt5lu",
    "property": "background-color",
    "selectors": [[".abcde"]],
    "value": "#f00"
  }

  t.deepEqual (actual, expect)
})

ava ("given an object with defined identifier", (t) => {
  const actual = parseIdentifier ({
    "identifier": "abcde",
    "property": "background-color",
    "value": "#f00"
  })

  const expect = {
    "identifier": "abcde",
    "property": "background-color",
    "selectors": [[".abcde"]],
    "value": "#f00"
  }

  t.deepEqual (actual, expect)
})

ava ("given an object with valid camel-case property and value", (t) => {
  const actual = parseIdentifier ({
    "property": "backgroundColor",
    "value": "#000"
  })

  const expect = {
    "identifier": "jt37r",
    "property": "backgroundColor",
    "selectors": [[".jt37r"]],
    "value": "#000"
  }

  t.deepEqual (actual, expect)
})

ava ("given an object with valid kebab-case property and value", (t) => {
  const actual = parseIdentifier ({
    "property": "background-color",
    "value": "#000"
  })

  const expect = {
    "identifier": "jt37r",
    "property": "background-color",
    "selectors": [[".jt37r"]],
    "value": "#000"
  }

  t.deepEqual (actual, expect)
})

ava ("given an object with valid property, value, and selectors", (t) => {
  const actual = parseIdentifier ({
    "property": "background-color",
    "selectors": [[":hover"]],
    "value": "#000"
  })

  const expect = {
    "identifier": "jta6z",
    "property": "background-color",
    "selectors": [[".jta6z", ":hover"]],
    "value": "#000"
  }

  t.deepEqual (actual, expect)
})

ava ("given an object with valid property, value, and media", (t) => {
  const actual = parseIdentifier ({
    "media": "(min-width: 768px)",
    "property": "background-color",
    "value": "#000"
  })

  const expect = {
    "identifier": "jt0ac",
    "media": "(min-width: 768px)",
    "property": "background-color",
    "selectors": [[".jt0ac"]],
    "value": "#000"
  }

  t.deepEqual (actual, expect)
})

ava (
  "given an object with valid property, value, media, and selectors",
  (t) => {
    const actual = parseIdentifier ({
      "media": "(min-width: 768px)",
      "property": "background-color",
      "selectors": [[":hover"]],
      "value": "#000"
    })

    const expect = {
      "identifier": "jtdo0",
      "media": "(min-width: 768px)",
      "property": "background-color",
      "selectors": [[".jtdo0", ":hover"]],
      "value": "#000"
    }

    t.deepEqual (actual, expect)
  }
)
#+end_src
#+HTML: </details>

**** parseInput

#+HTML: <details>
#+begin_src js :tangle src/parse/parse-input.js
import { camelCase } from "../utils/camel-case.js"
import { kebabCase } from "../utils/kebab-case.js"
import { toPairs } from "../utils/to-pairs.js"

export function parseInput (params = {}) {
  const emit = params.emit || true
  const input = params.input || {}
  const media = params.media || ""
  const selectors = params.selectors || []

  return toPairs (input).reduce (function (styles, style) {
    const property = style[0]
    const value = style[1]

    return styles.concat ({
      "block": [
        {
          [kebabCase (property)]: value
        }
      ],
      "emit": emit,
      "input": {
        [property]: value
      },
      "media": media,
      "property": camelCase (property),
      "selectors": selectors,
      "value": value
    })
  }, [])
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/parse/parse-input.test.js
import ava from "ava"
import { parseInput } from "./parse-input.js"

ava ("given undefined arguments", (t) => {
  const actual = parseInput ()
  const expect = []

  t.deepEqual (actual, expect)
})

ava ("given an object with multiple properties and values", (t) => {
  const actual = parseInput ({
    "input": {
      "backgroundColor": "#f00",
      "display": "block"
    }
  })

  const expect = [
    {
      "block": [
        {
          "background-color": "#f00"
        }
      ],
      "emit": true,
      "input": {
        "backgroundColor": "#f00"
      },
      "media": "",
      "property": "backgroundColor",
      "selectors": [],
      "value": "#f00"
    },
    {
      "block": [
        {
          "display": "block"
        }
      ],
      "emit": true,
      "input": {
        "display": "block"
      },
      "media": "",
      "property": "display",
      "selectors": [],
      "value": "block"
    }
  ]

  t.deepEqual (actual, expect)
})
#+end_src
#+HTML: </details>

**** parseMedia

#+HTML: <details>
#+begin_src js :tangle src/parse/parse-media.js
import { kebabCase } from "../utils/kebab-case.js"
import { parse } from "./parse.js"

export function parseMedia (params = {}) {
  const property = params.property
  const value = params.value

  if ((/^@media/u).test (property) && typeof value === "object") {
    const media = [params.media, kebabCase (property.slice (7))]
      .filter (Boolean)
      .join (" and ")

    return parse ({ "input": value, media })
  }

  return params
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/parse/parse-media.test.js
import ava from "ava"
import { parseMedia } from "./parse-media.js"

ava ("given undefined arguments", (t) => {
  const actual = parseMedia ()

  const expect = {}

  t.deepEqual (actual, expect)
})

ava ("given an object with valid media declaration", (t) => {
  const actual = parseMedia ({
    "property": "@media (min-width: 768px)",
    "value": {
      "background-color": "#000"
    }
  })

  const expect = [
    {
      "block": [
        {
          "background-color": "#000"
        }
      ],
      "emit": true,
      "identifier": "jt0ac",
      "input": {
        "background-color": "#000"
      },
      "media": "(min-width: 768px)",
      "property": "backgroundColor",
      "selectors": [[".jt0ac"]],
      "value": "#000"
    }
  ]

  t.deepEqual (actual, expect)
})

ava ("given an object with complex valid media declaration", (t) => {
  const actual = parseMedia ({
    "property": "@media (min-width: 768px)",
    "value": {
      "@media (-webkit-min-device-pixel-ratio: 2)": {
        "background-color": "#000"
      }
    }
  })

  const expect = [
    {
      "block": [
        {
          "background-color": "#000"
        }
      ],
      "emit": true,
      "identifier": "jtnzy",
      "input": {
        "background-color": "#000"
      },
      "media": "(min-width: 768px) and (-webkit-min-device-pixel-ratio: 2)",
      "property": "backgroundColor",
      "selectors": [[".jtnzy"]],
      "value": "#000"
    }
  ]

  t.deepEqual (actual, expect)
})
#+end_src
#+HTML: </details>

**** parse

#+HTML: <details>
#+begin_src js :tangle src/parse/parse.js
import { parseInput } from "./parse-input.js"
import { parseIdentifier } from "./parse-identifier.js"
import { parseMedia } from "./parse-media.js"

export function parse (params = {}) {
  return parseInput (params)
    .reduce (function (styles, style) {
      return styles.concat (parseIdentifier (style))
    }, [])
    .reduce (function (styles, style) {
      return styles.concat (parseMedia (style))
    }, [])
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/parse/parse.test.js
import ava from "ava"
import { parse } from "./parse.js"

ava ("given undefined arguments", (t) => {
  const actual = parse ()

  const expect = []

  t.deepEqual (actual, expect)
})

ava ("given an object with valid property and value", (t) => {
  const actual = parse ({
    "input": {
      "background-color": "#f00",
      "display": "block"
    }
  })

  const expect = [
    {
      "block": [
        {
          "background-color": "#f00"
        }
      ],
      "emit": true,
      "identifier": "jt2a9",
      "input": {
        "background-color": "#f00"
      },
      "media": "",
      "property": "backgroundColor",
      "selectors": [[".jt2a9"]],
      "value": "#f00"
    },
    {
      "block": [
        {
          "display": "block"
        }
      ],
      "emit": true,
      "identifier": "drtx9",
      "input": {
        "display": "block"
      },
      "media": "",
      "property": "display",
      "selectors": [[".drtx9"]],
      "value": "block"
    }
  ]

  t.deepEqual (actual, expect)
})
#+end_src
#+HTML: </details>

*** Store

**** cache

#+HTML: <details>
#+begin_src js :tangle src/store/cache.js
import { store } from "./store.js"
import { merge } from "../utils/merge.js"

export function cache (params = {}) {
  const block = params.block || []
  const media = params.media || ""

  const key = JSON.stringify (block)

  if (!store.has (media)) {
    store.set (media, new Map ())
  }

  if (store.get (media).has (key)) {
    const style = store.get (media).get (key)

    const addSelector =
      style.selectors.findIndex (function (selector) {
        return selector.join ("") === params.selectors[0].join ("")
      }) < 0

    store.get (media).set (
      key,
      merge (
        params,
        {
          "selectors": null
        },
        {
          "selectors": addSelector
            ? style.selectors.concat (params.selectors)
            : style.selectors
        }
      )
    )
  } else {
    store.get (media).set (key, params)
  }

  return store.get (media).get (key)
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/store/cache.test.js
import ava from "ava"
import { cache } from "./cache.js"
import { store } from "./store.js"

ava.serial ("given undefined arguments", (t) => {
  const actual = cache ()

  const expect1 = {}
  const expect2 = store.has ("")
  const expect3 = store.get ("")

  t.deepEqual (actual, expect1)
  t.true (expect2)
  t.true (expect3 instanceof Map)
})

ava.serial ("given an object with valid property and value (1)", (t) => {
  const actual = cache ({
    "block": [
      {
        "background-color": "#f00"
      }
    ],
    "emit": true,
    "identifier": "jt2a9",
    "input": {
      "background-color": "#f00"
    },
    "media": "",
    "property": "backgroundColor",
    "selectors": [[".jt2a9"]],
    "value": "#f00"
  })

  const expect = {
    "block": [
      {
        "background-color": "#f00"
      }
    ],
    "emit": true,
    "identifier": "jt2a9",
    "input": {
      "background-color": "#f00"
    },
    "media": "",
    "property": "backgroundColor",
    "selectors": [[".jt2a9"]],
    "value": "#f00"
  }

  t.deepEqual (actual, expect)
})

ava.serial ("given an object with valid property and value (2)", (t) => {
  const actual = cache ({
    "block": [
      {
        "background-color": "#f00"
      }
    ],
    "emit": true,
    "identifier": "jtdzh",
    "input": {
      "background-color": "#f00"
    },
    "media": "",
    "property": "backgroundColor",
    "selectors": [[".jtdzh", ":hover"]],
    "value": "#f00"
  })

  const expect = {
    "block": [
      {
        "background-color": "#f00"
      }
    ],
    "emit": true,
    "identifier": "jtdzh",
    "input": {
      "background-color": "#f00"
    },
    "media": "",
    "property": "backgroundColor",
    "selectors": [[".jt2a9"], [".jtdzh", ":hover"]],
    "value": "#f00"
  }

  t.deepEqual (actual, expect)
})

ava.serial ("given an object with valid property and value (3)", (t) => {
  const actual = cache ({
    "block": [
      {
        "background-color": "#f00"
      }
    ],
    "emit": true,
    "identifier": "jtdzh",
    "input": {
      "background-color": "#f00"
    },
    "media": "",
    "property": "backgroundColor",
    "selectors": [[".jtdzh", ":hover"]],
    "value": "#f00"
  })

  const expect = {
    "block": [
      {
        "background-color": "#f00"
      }
    ],
    "emit": true,
    "identifier": "jtdzh",
    "input": {
      "background-color": "#f00"
    },
    "media": "",
    "property": "backgroundColor",
    "selectors": [[".jt2a9"], [".jtdzh", ":hover"]],
    "value": "#f00"
  }

  t.deepEqual (actual, expect)
})
#+end_src
#+HTML: </details>

**** store

#+HTML: <details>
#+begin_src js :tangle src/store/store.js
export const store = (function (STORE) {
  return STORE
}) (new Map ())
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/store/store.test.js
import ava from "ava"
import { store } from "./store.js"

ava.serial ("when 'store' module' is imported", (t) => {
  const actual = store instanceof Map

  t.true (actual)
})

ava.serial ("given 'true' is set for the 'one' key", (t) => {
  store.set ("one", true)

  const actual = store.get ("one")

  t.true (actual)
})

ava.serial ("given 'false' is set for the 'two' key", (t) => {
  store.set ("two", false)

  const actual = store.get ("two")

  t.false (actual)
})

ava.serial ("given 'true' is get for the 'one' key", (t) => {
  const actual = store.get ("one")

  t.true (actual)
})
#+end_src
#+HTML: </details>

*** Utils

**** camelCase

#+HTML: <details>
#+begin_src js :tangle src/utils/camel-case.js
/**
 * Converts `string` to camel case.
 *
 * @param {string} string
 * - The string to convert.
 *
 * @returns {string}
 *   The camel cased string.
 */

export function camelCase (string = "") {
  return string.replace (/\x2D([a-z])/gu, function (_, a) {
    return a.toUpperCase ()
  })
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/utils/camel-case.test.js
import ava from "ava"
import { camelCase } from "./camel-case.js"

ava ("given undefined arguments", (t) => {
  const actual = camelCase ()
  const expect = ""

  t.is (actual, expect)
})

ava ("given a string in kebab-case", (t) => {
  const actual = camelCase ("background-color")
  const expect = "backgroundColor"

  t.is (actual, expect)
})

ava ("given a string in camel-case", (t) => {
  const actual = camelCase ("backgroundColor")
  const expect = "backgroundColor"

  t.is (actual, expect)
})

ava ("given a string in lowercase", (t) => {
  const actual = camelCase ("background")
  const expect = "background"

  t.is (actual, expect)
})
#+end_src
#+HTML: </details>

**** kebabCase

#+HTML: <details>
#+begin_src js :tangle src/utils/kebab-case.js
/**
 * Converts `string` to kebab case.
 *
 * @param {string} string
 * - The string to convert.
 *
 * @returns {string}
 *   The kebab cased string.
 */

export function kebabCase (string = "") {
  return string.replace (/[A-Z]|^ms/gu, "-$&").toLowerCase ()
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/utils/kebab-case.test.js
import ava from "ava"
import { kebabCase } from "./kebab-case.js"

ava ("given undefined arguments", (t) => {
  const actual = kebabCase ()
  const expect = ""

  t.is (actual, expect)
})

ava ("given a string in camel-case", (t) => {
  const actual = kebabCase ("backgroundColor")
  const expect = "background-color"

  t.is (actual, expect)
})

ava ("given a string beginning with 'ms-'", (t) => {
  const actual = kebabCase ("msAccelerator")
  const expect = "-ms-accelerator"

  t.is (actual, expect)
})

ava ("given a string already in kebab-case", (t) => {
  const actual = kebabCase ("background-color")
  const expect = "background-color"

  t.is (actual, expect)
})

ava ("given a string with lowercase characters", (t) => {
  const actual = kebabCase ("background")
  const expect = "background"

  t.is (actual, expect)
})
#+end_src
#+HTML: </details>

**** merge

#+HTML: <details>
#+begin_src js :tangle src/utils/merge.js
/* eslint-disable no-use-before-define */

export const isArr = Array.isArray

export function isObj (value) {
  return typeof value === "object"
}

export function canMerge (value) {
  return (
    Boolean (value) &&
    isObj (value) &&
    !(/^\[object (?:Date|RegExp)\]$/u).test (
      Object.prototype.toString.call (value)
    )
  )
}

export function emptyObj (value) {
  return isArr (value) ? [] : {}
}

export function cloneObj (value) {
  return canMerge (value) ? merge (emptyObj (value), value) : value
}

export function mergeArr (target, source) {
  return (isArr (target) && isArr (source)
    ? target.concat (source)
    : source
  ).map (cloneObj)
}

export function mergeObj (target, source) {
  for (const key of Object.keys (source)) {
    target[key] = merge (
      Object.prototype.hasOwnProperty.call (target, key) ? target[key] : {},
      source[key]
    )
  }

  return target
}

/**
 * This method recursively merges own enumerable string keyed properties of
 * source objects into a new empty object. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * @param  {...Object} sources
 * - The source objects.
 *
 * @returns {Object}
 *   Returns `object`.
 */

export function merge (... sources) {
  return sources.reduce (function (target, source) {
    if (isArr (source)) {
      return mergeArr (target, source)
    } else if (canMerge (source)) {
      return mergeObj (target, source)
    }

    return cloneObj (source)
  }, {})
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/utils/merge.test.js

import ava from "ava"
import { emptyObj, merge } from "./merge.js"

ava ("given undefined arguments", (t) => {
  const actual = merge ()
  const expect = {}

  t.deepEqual (actual, expect)
})

ava ("given an array as value", (t) => {
  const actual = emptyObj (["a"])
  const expect = []

  t.deepEqual (actual, expect)
})

ava ("given an object as value", (t) => {
  const actual = emptyObj ({ "a": null })
  const expect = {}

  t.deepEqual (actual, expect)
})

ava ("given two objects", (t) => {
  const actual = merge ({ "a": null }, { "b": null })
  const expect = { "a": null, "b": null }

  t.deepEqual (actual, expect)
})

ava ("given two arrays", (t) => {
  const actual = merge (["a"], ["b"])
  const expect = ["a", "b"]

  t.deepEqual (actual, expect)
})

ava ("merge existing simple keys in target at the roots", (t) => {
  const actual = merge (
    { "key1": "value1", "key3": "value3" },
    { "key1": "changed", "key2": "value2" }
  )

  const expect = {
    "key1": "changed",
    "key2": "value2",
    "key3": "value3"
  }

  t.deepEqual (actual, expect)
})

ava ("should work on array of objects", (t) => {
  const actual = merge (
    [{ "key1": ["one", "two"] }, { "key3": ["four"] }],
    [{ "key1": ["one", "three"], "key2": ["one"] }, { "key3": ["five"] }]
  )

  const expect = [
    { "key1": ["one", "two"] },
    { "key3": ["four"] },
    { "key1": ["one", "three"], "key2": ["one"] },
    { "key3": ["five"] }
  ]

  t.deepEqual (actual, expect)
})
#+end_src
#+HTML: </details>

**** toPairs

#+HTML: <details>
#+begin_src js :tangle src/utils/to-pairs.js
export function toPairs (params = {}) {
  return Object.keys (params).map (function (key) {
    return [key, params[key]]
  })
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/utils/to-pairs.test.js
import ava from "ava"
import { toPairs } from "./to-pairs.js"

ava ("given undefined arguments", (t) => {
  const actual = toPairs ()
  const expect = []

  t.deepEqual (actual, expect)
})

ava ("given an object with property string and null value", (t) => {
  const actual = toPairs ({ "color": null })
  const expect = [["color", null]]

  t.deepEqual (actual, expect)
})

ava ("given an object with property string and boolean value", (t) => {
  const actual = toPairs ({ "color": true })
  const expect = [["color", true]]

  t.deepEqual (actual, expect)
})

ava ("given an object with property string and number value", (t) => {
  const actual = toPairs ({ "margin": 0 })
  const expect = [["margin", 0]]

  t.deepEqual (actual, expect)
})

ava ("given an object with property string and string value", (t) => {
  const actual = toPairs ({ "color": "red" })
  const expect = [["color", "red"]]

  t.deepEqual (actual, expect)
})

ava ("given an object with property string and array value", (t) => {
  const actual = toPairs ({ "color": [0, 1] })
  const expect = [["color", [0, 1]]]

  t.deepEqual (actual, expect)
})

ava ("given an object with property string and object value", (t) => {
  const actual = toPairs ({ "color": { "a": 1 } })
  const expect = [["color", { "a": 1 }]]

  t.deepEqual (actual, expect)
})
#+end_src
#+HTML: </details>
