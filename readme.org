* @amory/style
:properties:
:header-args: :cache yes :comments no :mkdirp yes :padline yes :results silent
:end:
#+startup: showall nohideblocks hidestars indent

** Table of Contents                                                   :TOC:
- [[#amorystyle][@amory/style]]
  - [[#license][License]]
  - [[#source][Source]]
    - [[#api][API]]
      - [[#index][index]]
    - [[#parse][Parse]]
      - [[#parseinput][parseInput]]
    - [[#utils][Utils]]
      - [[#camelcase][camelCase]]
      - [[#kebabcase][kebabCase]]
      - [[#merge][merge]]
      - [[#topairs][toPairs]]

** License

#+begin_quote
Copyright 2019 [[https://github.com/ptb][Peter T Bosse II]]

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
#+end_quote

** Source

*** API

**** index

#+HTML: <details>
#+begin_src js :tangle src/api/index.js
export { parseInput } from "../parse/parse-input.js"
export { camelCase } from "../utils/camel-case.js"
export { kebabCase } from "../utils/kebab-case.js"
export {
  canMerge,
  cloneObj,
  emptyObj,
  isArr,
  isObj,
  merge,
  mergeArr,
  mergeObj
} from "../utils/merge.js"
export { toPairs } from "../utils/to-pairs.js"
#+end_src
#+HTML: </details>

*** Parse

**** parseInput

#+HTML: <details>
#+begin_src js :tangle src/parse/parse-input.js
import { camelCase } from "../utils/camel-case.js"
import { kebabCase } from "../utils/kebab-case.js"
import { toPairs } from "../utils/to-pairs.js"

export function parseInput (params = {}) {
  const emit = params.emit || true
  const input = params.input || {}
  const media = params.media || ""
  const selectors = params.selectors || []

  return toPairs (input).reduce (function (styles, style) {
    const property = style[0]
    const value = style[1]

    return styles.concat ({
      "block": [
        {
          [kebabCase (property)]: value
        }
      ],
      "emit": emit,
      "input": {
        [property]: value
      },
      "media": media,
      "property": camelCase (property),
      "selectors": selectors,
      "value": value
    })
  }, [])
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/parse/parse-input.test.js
import ava from "ava"
import { parseInput } from "./parse-input.js"

ava ("given undefined arguments", (t) => {
  const actual = parseInput ()
  const expect = []

  t.deepEqual (actual, expect)
})

ava ("given an object with multiple properties and values", (t) => {
  const actual = parseInput ({
    "input": {
      "backgroundColor": "#f00",
      "display": "block"
    }
  })

  const expect = [
    {
      "block": [
        {
          "background-color": "#f00"
        }
      ],
      "emit": true,
      "input": {
        "backgroundColor": "#f00"
      },
      "media": "",
      "property": "backgroundColor",
      "selectors": [],
      "value": "#f00"
    },
    {
      "block": [
        {
          "display": "block"
        }
      ],
      "emit": true,
      "input": {
        "display": "block"
      },
      "media": "",
      "property": "display",
      "selectors": [],
      "value": "block"
    }
  ]

  t.deepEqual (actual, expect)
})
#+end_src
#+HTML: </details>

*** Utils

**** camelCase

#+HTML: <details>
#+begin_src js :tangle src/utils/camel-case.js
/**
 * Converts `string` to camel case.
 *
 * @param {string} string
 * - The string to convert.
 *
 * @returns {string}
 *   The camel cased string.
 */

export function camelCase (string = "") {
  return string.replace (/\x2D([a-z])/gu, function (_, a) {
    return a.toUpperCase ()
  })
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/utils/camel-case.test.js
import ava from "ava"
import { camelCase } from "./camel-case.js"

ava ("given undefined arguments", (t) => {
  const actual = camelCase ()
  const expect = ""

  t.is (actual, expect)
})

ava ("given a string in kebab-case", (t) => {
  const actual = camelCase ("background-color")
  const expect = "backgroundColor"

  t.is (actual, expect)
})

ava ("given a string in camel-case", (t) => {
  const actual = camelCase ("backgroundColor")
  const expect = "backgroundColor"

  t.is (actual, expect)
})

ava ("given a string in lowercase", (t) => {
  const actual = camelCase ("background")
  const expect = "background"

  t.is (actual, expect)
})
#+end_src
#+HTML: </details>

**** kebabCase

#+HTML: <details>
#+begin_src js :tangle src/utils/kebab-case.js
/**
 * Converts `string` to kebab case.
 *
 * @param {string} string
 * - The string to convert.
 *
 * @returns {string}
 *   The kebab cased string.
 */

export function kebabCase (string = "") {
  return string.replace (/[A-Z]|^ms/gu, "-$&").toLowerCase ()
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/utils/kebab-case.test.js
import ava from "ava"
import { kebabCase } from "./kebab-case.js"

ava ("given undefined arguments", (t) => {
  const actual = kebabCase ()
  const expect = ""

  t.is (actual, expect)
})

ava ("given a string in camel-case", (t) => {
  const actual = kebabCase ("backgroundColor")
  const expect = "background-color"

  t.is (actual, expect)
})

ava ("given a string beginning with 'ms-'", (t) => {
  const actual = kebabCase ("msAccelerator")
  const expect = "-ms-accelerator"

  t.is (actual, expect)
})

ava ("given a string already in kebab-case", (t) => {
  const actual = kebabCase ("background-color")
  const expect = "background-color"

  t.is (actual, expect)
})

ava ("given a string with lowercase characters", (t) => {
  const actual = kebabCase ("background")
  const expect = "background"

  t.is (actual, expect)
})
#+end_src
#+HTML: </details>

**** merge

#+HTML: <details>
#+begin_src js :tangle src/utils/merge.js
/* eslint-disable no-use-before-define */

export const isArr = Array.isArray

export function isObj (value) {
  return typeof value === "object"
}

export function canMerge (value) {
  return (
    Boolean (value) &&
    isObj (value) &&
    !(/^\[object (?:Date|RegExp)\]$/u).test (
      Object.prototype.toString.call (value)
    )
  )
}

export function emptyObj (value) {
  return isArr (value) ? [] : {}
}

export function cloneObj (value) {
  return canMerge (value) ? merge (emptyObj (value), value) : value
}

export function mergeArr (target, source) {
  return (isArr (target) && isArr (source)
    ? target.concat (source)
    : source
  ).map (cloneObj)
}

export function mergeObj (target, source) {
  for (const key of Object.keys (source)) {
    target[key] = merge (
      Object.prototype.hasOwnProperty.call (target, key) ? target[key] : {},
      source[key]
    )
  }

  return target
}

/**
 * This method recursively merges own enumerable string keyed properties of
 * source objects into a new empty object. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * @param  {...Object} sources
 * - The source objects.
 *
 * @returns {Object}
 *   Returns `object`.
 */

export function merge (... sources) {
  return sources.reduce (function (target, source) {
    if (isArr (source)) {
      return mergeArr (target, source)
    } else if (canMerge (source)) {
      return mergeObj (target, source)
    }

    return cloneObj (source)
  }, {})
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/utils/merge.test.js

import ava from "ava"
import { emptyObj, merge } from "./merge.js"

ava ("given undefined arguments", (t) => {
  const actual = merge ()
  const expect = {}

  t.deepEqual (actual, expect)
})

ava ("given an array as value", (t) => {
  const actual = emptyObj (["a"])
  const expect = []

  t.deepEqual (actual, expect)
})

ava ("given an object as value", (t) => {
  const actual = emptyObj ({ "a": null })
  const expect = {}

  t.deepEqual (actual, expect)
})

ava ("given two objects", (t) => {
  const actual = merge ({ "a": null }, { "b": null })
  const expect = { "a": null, "b": null }

  t.deepEqual (actual, expect)
})

ava ("given two arrays", (t) => {
  const actual = merge (["a"], ["b"])
  const expect = ["a", "b"]

  t.deepEqual (actual, expect)
})

ava ("merge existing simple keys in target at the roots", (t) => {
  const actual = merge (
    { "key1": "value1", "key3": "value3" },
    { "key1": "changed", "key2": "value2" }
  )

  const expect = {
    "key1": "changed",
    "key2": "value2",
    "key3": "value3"
  }

  t.deepEqual (actual, expect)
})

ava ("should work on array of objects", (t) => {
  const actual = merge (
    [{ "key1": ["one", "two"] }, { "key3": ["four"] }],
    [{ "key1": ["one", "three"], "key2": ["one"] }, { "key3": ["five"] }]
  )

  const expect = [
    { "key1": ["one", "two"] },
    { "key3": ["four"] },
    { "key1": ["one", "three"], "key2": ["one"] },
    { "key3": ["five"] }
  ]

  t.deepEqual (actual, expect)
})
#+end_src
#+HTML: </details>

**** toPairs

#+HTML: <details>
#+begin_src js :tangle src/utils/to-pairs.js
export function toPairs (params = {}) {
  return Object.keys (params).map (function (key) {
    return [key, params[key]]
  })
}
#+end_src
#+HTML: </details>

#+HTML: <details>
#+begin_src js :tangle src/utils/to-pairs.test.js
import ava from "ava"
import { toPairs } from "./to-pairs.js"

ava ("given undefined arguments", (t) => {
  const actual = toPairs ()
  const expect = []

  t.deepEqual (actual, expect)
})

ava ("given an object with property string and null value", (t) => {
  const actual = toPairs ({ "color": null })
  const expect = [["color", null]]

  t.deepEqual (actual, expect)
})

ava ("given an object with property string and boolean value", (t) => {
  const actual = toPairs ({ "color": true })
  const expect = [["color", true]]

  t.deepEqual (actual, expect)
})

ava ("given an object with property string and number value", (t) => {
  const actual = toPairs ({ "margin": 0 })
  const expect = [["margin", 0]]

  t.deepEqual (actual, expect)
})

ava ("given an object with property string and string value", (t) => {
  const actual = toPairs ({ "color": "red" })
  const expect = [["color", "red"]]

  t.deepEqual (actual, expect)
})

ava ("given an object with property string and array value", (t) => {
  const actual = toPairs ({ "color": [0, 1] })
  const expect = [["color", [0, 1]]]

  t.deepEqual (actual, expect)
})

ava ("given an object with property string and object value", (t) => {
  const actual = toPairs ({ "color": { "a": 1 } })
  const expect = [["color", { "a": 1 }]]

  t.deepEqual (actual, expect)
})
#+end_src
#+HTML: </details>
